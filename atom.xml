<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Navy&#39;s Blog</title>
  
  <subtitle>行之于途而应于心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.lzxy169.com/"/>
  <updated>2018-04-18T15:36:15.511Z</updated>
  <id>http://blog.lzxy169.com/</id>
  
  <author>
    <name>Navy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ARC(Automatic Reference Counting)简记</title>
    <link href="http://blog.lzxy169.com/2018/04/16/arc-record/"/>
    <id>http://blog.lzxy169.com/2018/04/16/arc-record/</id>
    <published>2018-04-16T02:29:09.000Z</published>
    <updated>2018-04-18T15:36:15.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ARC概述"><a href="#ARC概述" class="headerlink" title="ARC概述"></a>ARC概述</h2><p>　　在Objective-C中采用Automatic Reference Counting(ARC)机制，让编译器(<a href="http://clang.org/" target="_blank" rel="noopener">clang</a>)和运行时库协助(<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc4</a>)来进行内存管理。</p><h3 id="内存管理的思考方式"><a href="#内存管理的思考方式" class="headerlink" title="内存管理的思考方式"></a>内存管理的思考方式</h3><ul><li>自己生成的对象，自己持有</li><li>非自己生成的对象，自己也能持有</li><li>不再需要自己持有的对象时释放</li><li>非自己持有的对象无法释放</li></ul><p><strong>对象操作与Objective-C方法的对应：</strong></p><table><thead><tr><th>对象操作</th><th>Objective-C方法</th></tr></thead><tbody><tr><td>生成并持有对象</td><td>alloc/new/copy/mutableCopy 等方法</td></tr><tr><td>持有对象</td><td>retain方法</td></tr><tr><td>释放对象</td><td>release方法</td></tr><tr><td>废弃对象</td><td>dealloc方法</td></tr></tbody></table><blockquote><p>“自己”：对象的使用环境</p></blockquote><p><strong>苹果采用散列表(引用计数表)来管理引用计数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    CFLock_t lock;</span><br><span class="line">    CFBasicHashRef table;</span><br><span class="line"><span class="comment">//    uint8_t padding[64 - sizeof(CFBasicHashRef) - sizeof(CFLock_t)];</span></span><br><span class="line">&#125; __NSRetainCounters[NUM_EXTERN_TABLES];</span><br><span class="line"></span><br><span class="line">CF_EXPORT <span class="keyword">uintptr_t</span> __CFDoExternRefOperation(<span class="keyword">uintptr_t</span> op, id obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nil == obj) HALT;</span><br><span class="line">    <span class="keyword">uintptr_t</span> idx = EXTERN_TABLE_IDX(obj);</span><br><span class="line">    <span class="keyword">uintptr_t</span> disguised = DISGUISE(obj);</span><br><span class="line">    CFLock_t *lock = &amp;__NSRetainCounters[idx].lock;</span><br><span class="line">    CFBasicHashRef table = __NSRetainCounters[idx].table;  <span class="comment">// 取得对象对应的散列表</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> count;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">300</span>:   <span class="comment">// increment</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">350</span>:   <span class="comment">// increment, no event</span></span><br><span class="line">        __CFLock(lock);</span><br><span class="line">    CFBasicHashAddValue(table, disguised, disguised);</span><br><span class="line">        __CFUnlock(lock);</span><br><span class="line">        <span class="keyword">if</span> (__CFOASafe &amp;&amp; op != <span class="number">350</span>) __CFRecordAllocationEvent(__kCFObjectRetainedEvent, obj, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">uintptr_t</span>)obj;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">400</span>:   <span class="comment">// decrement</span></span><br><span class="line">        <span class="keyword">if</span> (__CFOASafe) __CFRecordAllocationEvent(__kCFObjectReleasedEvent, obj, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">450</span>:   <span class="comment">// decrement, no event</span></span><br><span class="line">        __CFLock(lock);</span><br><span class="line">        count = (<span class="keyword">uintptr_t</span>)CFBasicHashRemoveValue(table, disguised);</span><br><span class="line">        __CFUnlock(lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> == count;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">500</span>:</span><br><span class="line">        __CFLock(lock);</span><br><span class="line">        count = (<span class="keyword">uintptr_t</span>)CFBasicHashGetCountOfKey(table, disguised);</span><br><span class="line">        __CFUnlock(lock);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">CF-1153.18/CFRuntime.c</a></p><p><strong>CFBasicHashRef</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CF_PRIVATE CFBasicHashRef <span class="title">CFBasicHashCreate</span><span class="params">(CFAllocatorRef allocator, CFOptionFlags flags, <span class="keyword">const</span> CFBasicHashCallbacks *cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = <span class="keyword">sizeof</span>(struct __CFBasicHash) - <span class="keyword">sizeof</span>(CFRuntimeBase);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; kCFBasicHashHasKeys) size += <span class="keyword">sizeof</span>(CFBasicHashValue *); <span class="comment">// keys</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; kCFBasicHashHasCounts) size += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *); <span class="comment">// counts</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; kCFBasicHashHasHashCache) size += <span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span> *); <span class="comment">// hashes</span></span><br><span class="line">    CFBasicHashRef ht = (CFBasicHashRef)_CFRuntimeCreateInstance(allocator, CFBasicHashGetTypeID(), size, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == ht) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ht-&gt;bits.finalized = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.hash_style = (flags &gt;&gt; <span class="number">13</span>) &amp; <span class="number">0x3</span>;</span><br><span class="line">    ht-&gt;bits.fast_grow = (flags &amp; kCFBasicHashAggressiveGrowth) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.counts_width = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.strong_values = (flags &amp; kCFBasicHashStrongValues) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.strong_keys = (flags &amp; kCFBasicHashStrongKeys) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.weak_values = (flags &amp; kCFBasicHashWeakValues) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.weak_keys = (flags &amp; kCFBasicHashWeakKeys) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.int_values = (flags &amp; kCFBasicHashIntegerValues) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.int_keys = (flags &amp; kCFBasicHashIntegerKeys) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.indirect_keys = (flags &amp; kCFBasicHashIndirectKeys) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.num_buckets_idx = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.used_buckets = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.deleted = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.mutations = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;bits.strong_values &amp;&amp; ht-&gt;bits.weak_values) HALT;</span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;bits.strong_values &amp;&amp; ht-&gt;bits.int_values) HALT;</span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;bits.strong_keys &amp;&amp; ht-&gt;bits.weak_keys) HALT;</span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;bits.strong_keys &amp;&amp; ht-&gt;bits.int_keys) HALT;</span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;bits.weak_values &amp;&amp; ht-&gt;bits.int_values) HALT;</span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;bits.weak_keys &amp;&amp; ht-&gt;bits.int_keys) HALT;</span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;bits.indirect_keys &amp;&amp; ht-&gt;bits.strong_keys) HALT;</span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;bits.indirect_keys &amp;&amp; ht-&gt;bits.weak_keys) HALT;</span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;bits.indirect_keys &amp;&amp; ht-&gt;bits.int_keys) HALT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> offset = <span class="number">1</span>;</span><br><span class="line">    ht-&gt;bits.keys_offset = (flags &amp; kCFBasicHashHasKeys) ? offset++ : <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.counts_offset = (flags &amp; kCFBasicHashHasCounts) ? offset++ : <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.hashes_offset = (flags &amp; kCFBasicHashHasHashCache) ? offset++ : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">    ht-&gt;bits.hashes_offset = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.strong_values = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.strong_keys = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.weak_values = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.weak_keys = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ht-&gt;bits.__kret = CFBasicHashGetPtrIndex((<span class="keyword">void</span> *)cb-&gt;retainKey);</span><br><span class="line">    ht-&gt;bits.__vret = CFBasicHashGetPtrIndex((<span class="keyword">void</span> *)cb-&gt;retainValue);</span><br><span class="line">    ht-&gt;bits.__krel = CFBasicHashGetPtrIndex((<span class="keyword">void</span> *)cb-&gt;releaseKey);</span><br><span class="line">    ht-&gt;bits.__vrel = CFBasicHashGetPtrIndex((<span class="keyword">void</span> *)cb-&gt;releaseValue);</span><br><span class="line">    ht-&gt;bits.__kdes = CFBasicHashGetPtrIndex((<span class="keyword">void</span> *)cb-&gt;copyKeyDescription);</span><br><span class="line">    ht-&gt;bits.__vdes = CFBasicHashGetPtrIndex((<span class="keyword">void</span> *)cb-&gt;copyValueDescription);</span><br><span class="line">    ht-&gt;bits.__kequ = CFBasicHashGetPtrIndex((<span class="keyword">void</span> *)cb-&gt;equateKeys);</span><br><span class="line">    ht-&gt;bits.__vequ = CFBasicHashGetPtrIndex((<span class="keyword">void</span> *)cb-&gt;equateValues);</span><br><span class="line">    ht-&gt;bits.__khas = CFBasicHashGetPtrIndex((<span class="keyword">void</span> *)cb-&gt;hashKey);</span><br><span class="line">    ht-&gt;bits.__kget = CFBasicHashGetPtrIndex((<span class="keyword">void</span> *)cb-&gt;getIndirectKey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (CFIndex idx = <span class="number">0</span>; idx &lt; offset; idx++) &#123;</span><br><span class="line">        ht-&gt;pointers[idx] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE_MEMORY_COUNTERS</span></span><br><span class="line">    <span class="keyword">int64_t</span> size_now = OSAtomicAdd64Barrier((<span class="keyword">int64_t</span>) CFBasicHashGetSize(ht, <span class="literal">true</span>), &amp; __CFBasicHashTotalSize);</span><br><span class="line">    <span class="keyword">while</span> (__CFBasicHashPeakSize &lt; size_now &amp;&amp; !OSAtomicCompareAndSwap64Barrier(__CFBasicHashPeakSize, size_now, &amp; __CFBasicHashPeakSize));</span><br><span class="line">    <span class="keyword">int64_t</span> count_now = OSAtomicAdd64Barrier(<span class="number">1</span>, &amp; __CFBasicHashTotalCount);</span><br><span class="line">    <span class="keyword">while</span> (__CFBasicHashPeakCount &lt; count_now &amp;&amp; !OSAtomicCompareAndSwap64Barrier(__CFBasicHashPeakCount, count_now, &amp; __CFBasicHashPeakCount));</span><br><span class="line">    OSAtomicAdd32Barrier(<span class="number">1</span>, &amp;__CFBasicHashSizes[ht-&gt;bits.num_buckets_idx]);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ht;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">CF-1153.18/CFBasicHash.c</a></p><h3 id="所有权修饰符"><a href="#所有权修饰符" class="headerlink" title="所有权修饰符"></a>所有权修饰符</h3><p>　　Objective-C 中为了处理对象，将类型定义为 id 类型或各种对象类型<br>　　id 类型用于隐藏类型的类名，相当于C语言中的 void *。</p><ul><li><strong>__strong：</strong> 表示对对象的“强引用”。持有强引用的变量，在超出其作用域时强引用失效，所以自动地释放自己持有的对象，对象的所有者不存在，因此废弃该对象。该修饰符是 id 类型和对象类型默认的所有权修饰符。</li><li><strong>__weak：</strong> 表示对对象的“弱引用”。持有弱引用的变量，在超出其作用域时，对象即被释放。在持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效且被赋值为 nil (空弱引用)。</li><li><strong>__unsafe_unretained：</strong> 附有该修饰符的变量不属于编译器的内存管理对象。既不持有对象的强引用也不持有对象的弱引用，只是表示对象，若该对象被废弃，其为悬垂指针。</li><li><strong>__autoreleasing：</strong> </li></ul><p><strong>属性声明的属性与所有权修饰符的对应关系</strong></p><table><thead><tr><th>属性声明的属性</th><th>所有权修饰符</th></tr></thead><tbody><tr><td>assign</td><td>__unsafe_unretained</td></tr><tr><td>copy</td><td>__strong (赋值的是被复制的对象)</td></tr><tr><td>retain</td><td>__strong</td></tr><tr><td>strong</td><td>__strong</td></tr><tr><td>weak</td><td>__weak</td></tr><tr><td>unsafe_unretained</td><td>__unsafe_unretained</td></tr></tbody></table><blockquote><p>内存泄漏就是应当废弃的对象在超出其生存周期后继续存在。相互引用(循环引用)容易发生内存泄漏。</p></blockquote><blockquote><p>野指针是指向“垃圾”内存（不可用内存）的指针。不是NULL指针。</p></blockquote><blockquote><p>悬垂指针是指指向曾经存在的对象，但该对象已经不再存在了。</p></blockquote><blockquote><p>附有 __strong 和 __weak 修饰符的变量类似于C++中的智能指针 std::shared_ptr 和 std::weak_ptr。std::shared_ptr 可通过引用计数来持有C++ 类实例，std::weak_ptr 可避免循环引用。</p></blockquote><h3 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h3><p>　　类似于C语言中的自动变量(局部变量)的特性。若某自动变量超出其作用域，改自动变量将被自动废弃。</p><p><strong>autorelease 的具体用法：</strong></p><ul><li>生成并持有 NSAutoreleasePool 对象</li><li>调用已分配对象的 autorelease 实例方法</li><li>废弃 NSAutoreleasePool 对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* ARC无效 */</span><br><span class="line">NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];</span><br><span class="line">// 等同于 objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">[obj autorelease];</span><br><span class="line">// 等同于 objc_autorelease(obj);</span><br><span class="line"></span><br><span class="line">[pool drain];</span><br><span class="line">// 等同于 objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">/* ARC有效 */</span><br><span class="line">@autoreleasepool &#123; // 显式</span><br><span class="line">    id __autoreleasing obj = [[NSObject alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@autoreleasepool &#123; // 非显式</span><br><span class="line">    // 非自己生成并持有的对象</span><br><span class="line">    id __strong obj = [NSMutableArray array];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>　　ARC有效时，指定“@autoreleasepool 块”来代替“NSAutoreleasePool 类对象生成，持有以及废弃”。通过将对象赋值给附加了__autoreleasing 修饰符的变量来代替调用 autorelease 方法。对象赋值给附有 __autoreleasing 修饰符的变量等价于在ARC无效时调用对象的 autorelease 方法，即对象被注册到 autoreleasepool 。</p><p>　　非显式地使用 __autoreleasing 也可以。这是由于编译器会检查<strong>方法名</strong>是否以 alloc/new/copy/mutableCopy 开始，如果不是则自动将返回的对象注册到 autoreleasepool 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (id)array &#123;</span><br><span class="line">    id obj = [[NSMutableArray alloc] init];</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　以上为取得非自己生成并持有的对象时被调用方法的源代码示例。因为没有显式指定所有权修饰符所以 id obj 同附有 __strong 修饰符的 id __strong obj 是完全一样的。由于 return 使得对象变量超出其作用域，所以该强引用对应的自己持有的对象会被自动释放，但该对象作为函数的返回值，编译器会自动将其注册到 autoreleasepool 中。</p><p>　　id 的指针(id *obj)或对象的指针(NSObject **obj)在没有显式指定时会被附加上 __autoreleasing 修饰符。使用附有 __autoreleasing 修饰符的变量作为对象取得参数，都会注册到 autoreleasepool ， 并取得非自己生成并持有的对象。 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)performOperationWithError:(NSError * __autoreleasing *)error &#123;</span><br><span class="line">    *error = [[NSError alloc] initWithDomain:@&quot;Domain&quot; code:0 userInfo:nil];</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用方法</span><br><span class="line">NSError __strong *error = nil;</span><br><span class="line">BOOL result = [obj performOperationWithError: &amp;error];</span><br><span class="line"></span><br><span class="line">编译器转化上述代码为下：</span><br><span class="line"></span><br><span class="line">NSError __strong *error = nil;</span><br><span class="line">NSError __autoreleasing *tmp = error;</span><br><span class="line">BOOL result = [obj performOperationWithError: &amp;tmp];</span><br><span class="line">error = tmp;</span><br></pre></td></tr></table></figure></p><blockquote><p>在显式地指定 __autoreleasing 修饰符时，必须注意对象变量要为自动变量(包括局部变量，函数，以及方法参数)。</p></blockquote><p>　　在访问附有 __weak 修饰符的变量时，实际上必定要访问注册到 autoreleasepool 的对象。为什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">id __strong obj0 = [[NSObject alloc] init];</span><br><span class="line">id __weak obj1 = obj0;</span><br><span class="line">NSLog(@&quot;class = %@&quot;, [obj1 class]);</span><br><span class="line"></span><br><span class="line">编译器转化上述代码为下：</span><br><span class="line">id __weak obj1 = obj0;</span><br><span class="line">id __autoreleasing tmp = obj1;</span><br><span class="line">NSLog(@&quot;class = %@&quot;, [tmp class]);</span><br></pre></td></tr></table></figure></p><p>　　这是因为 __weak 修饰符只持有对象的弱引用，而在访问引用对象的过程中，该对象有可能被废弃。如果把要访问的对象注册到 autoreleasepool 中，那么在 @autoreleasepool 块结束之前都能确保该对象存在。</p><p>　　在Cocoa框架中，相当于主循环的 NSRunLoop 或者在其他程序可运行的地方，对 NSAutoreleasePool 对象进行生成，持有和废弃处理。</p><p>　　Cocoa框架中有很多类方法用于返回 autorelease 的对象。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id array = [NSMutableArray arrayWithCapacity:1];</span><br><span class="line">id array2 = [[[NSMutableArray alloc] initWithCapacity:1] autorelease];</span><br></pre></td></tr></table></figure></p><blockquote><p>无论ARC是否有效，调试用的非公开函数 __objc__autoreleasePoolPrint() 都可使用。利用这一函数可调试注册到 autoreleasepool 上的对象。</p></blockquote><p><strong>autorelease 的实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePoolPage</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function">id *<span class="title">add</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        id *ret = next;  <span class="comment">// faster than `return next-1` because of aliasing</span></span><br><span class="line">        *next++ = obj;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">releaseAll</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        releaseUntil(begin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> id <span class="title">autorelease</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        assert(obj);</span><br><span class="line">        assert(!obj-&gt;isTaggedPointer());</span><br><span class="line">        id *dest __unused = autoreleaseFast(obj);</span><br><span class="line">        assert(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        id *dest;</span><br><span class="line">        <span class="keyword">if</span> (DebugPoolAllocation) &#123;</span><br><span class="line">            <span class="comment">// Each autorelease pool starts on a new pool page.</span></span><br><span class="line">            dest = autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dest = autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">        &#125;</span><br><span class="line">        assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class="line">        <span class="keyword">return</span> dest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span> *token)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        AutoreleasePoolPage *page;</span><br><span class="line">        id *stop;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (token == (<span class="keyword">void</span>*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">            <span class="comment">// Popping the top-level placeholder pool.</span></span><br><span class="line">            <span class="keyword">if</span> (hotPage()) &#123;</span><br><span class="line">                <span class="comment">// Pool was used. Pop its contents normally.</span></span><br><span class="line">                <span class="comment">// Pool pages remain allocated for re-use as usual.</span></span><br><span class="line">                pop(coldPage()-&gt;begin());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Pool was never used. Clear the placeholder.</span></span><br><span class="line">                setHotPage(nil);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        page = pageForPointer(token);</span><br><span class="line">        stop = (id *)token;</span><br><span class="line">        <span class="keyword">if</span> (*stop != POOL_BOUNDARY) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stop == page-&gt;begin()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">                <span class="comment">// Start of coldest page may correctly not be POOL_BOUNDARY:</span></span><br><span class="line">                <span class="comment">// 1. top-level pool is popped, leaving the cold page in place</span></span><br><span class="line">                <span class="comment">// 2. an object is autoreleased with no pool</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Error. For bincompat purposes this is not </span></span><br><span class="line">                <span class="comment">// fatal in executables built with old SDKs.</span></span><br><span class="line">                <span class="keyword">return</span> badPop(token);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintPoolHiwat) printHiwat();</span><br><span class="line"></span><br><span class="line">        page-&gt;releaseUntil(stop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// memory: delete empty children</span></span><br><span class="line">        <span class="keyword">if</span> (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">            <span class="comment">// special case: delete everything during page-per-pool debugging</span></span><br><span class="line">            AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">            page-&gt;kill();</span><br><span class="line">            setHotPage(parent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">            <span class="comment">// special case: delete everything for pop(top) </span></span><br><span class="line">            <span class="comment">// when debugging missing autorelease pools</span></span><br><span class="line">            page-&gt;kill();</span><br><span class="line">            setHotPage(nil);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child) &#123;</span><br><span class="line">            <span class="comment">// hysteresis: keep one empty child if page is more than half full</span></span><br><span class="line">            <span class="keyword">if</span> (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">                page-&gt;child-&gt;kill();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</span><br><span class="line">                page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r __unused = pthread_key_init_np(AutoreleasePoolPage::key, </span><br><span class="line">                                             AutoreleasePoolPage::tls_dealloc);</span><br><span class="line">        assert(r == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc4-706/runtime/NSObject.mm</a></p><h2 id="ARC规则"><a href="#ARC规则" class="headerlink" title="ARC规则"></a>ARC规则</h2><ul><li>不能使用 retain/release/retainCount/autorelease。在ARC下，内存管理是编译器的工作。</li><li>不能使用 NSAllocateObject/NSDeallocateObject</li><li>须遵守内存管理的方法命名规则。alloc/new/copy/mutableCopy，以这些名称开始的方法在返回对象时，必须返回给调用方所应当持有的对象。以 init 开始的方法必须是实例方法，并且必须要返回对象。返回的对象应为 id 类型或该方法声明类的对象类型，抑或是该类的超类或子类型。该返回对象不注册到 autoreleasepool 中。 基本上只是对 alloc 方法返回值的对象进行初始化处理并返回该对象。</li><li>不要显式调用 dealloc。 无论 ARC 是否有效，只要对象的所有者都不持有该对象，该对象就被废弃。对象被废弃时，不管 ARC 是否有效，都会调用对象的 dealloc 方法。</li><li>使用@autoreleasepool 块代替 NSAutoreleasePool </li><li>不能使用区域(NSZone)</li><li>对象型变量不能作为C语言结构体(struct/union)的成员。C语言的规范上没有方法来管理结构体成员的生存周期。要把对象型变量加入到结构体成员中时，可强制转换为 void *，或者时附加 __unsafe_unretained 。 附有该修饰符的变量不属于编译器的内存管理对象。</li><li>显式转换“ id ”和“ void * ”。</li></ul><p><strong>__bridge 转换</strong>  单纯的赋值转换。注意转换为 void * 的 __bridge 转换其安全性与赋值给 __unsafe_unretained 修饰符相近，甚至会更低。如果不注意赋值对象的所有者，就会因悬垂指针而导致程序崩溃。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">void *p = (__bridge void *)obj;</span><br><span class="line">id o = (__bridge id)p;</span><br></pre></td></tr></table></figure></p><p><strong>__bridge_retained 转换</strong> 可使要转换赋值的变量也持有所赋值的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">void *p = (__bridge_retained void *)obj;</span><br></pre></td></tr></table></figure></p><p><strong>__bridge_transfer 转换</strong> 被转换的变量所持有的对象在该变量被赋值给转换目标变量后随之释放。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">void *p = (__bridge_retained void *)obj;</span><br><span class="line"></span><br><span class="line">id obj1 = (__bridge_transfer id)p;</span><br></pre></td></tr></table></figure></p><p>　　以下函数可用于 Objective-C 对象与 Core Foundation 对象之间的相互变换，即 Toll-Free-Bridge 转化。由于这种转换不需要使用额外的CPU资源，因此也被称为“免费桥”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CFTypeRef CFBridgingRetain(id  _Nullable X) &#123;</span><br><span class="line">    return (__bridge_retained CFTypeRef)X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id CFBridgingRelease(CFTypeRef  _Nullable X) &#123;</span><br><span class="line">        return (__bridge_transfer id)X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *obj = [[NSMutableArray alloc] initWithCapacity:1];</span><br><span class="line">CFMutableArrayRef cfobject = CFBridgingRetain(obj);</span><br><span class="line">CFShow(cfobject);</span><br><span class="line">CFRelease(cfobject);</span><br><span class="line"></span><br><span class="line">CFMutableArrayRef cfobject = CFArrayCreateMutable(kCFAllocatorDefault, 0, NULL);</span><br><span class="line">id obj = CFBridgingRelease(cfobject);</span><br></pre></td></tr></table></figure></p><h2 id="ARC实现"><a href="#ARC实现" class="headerlink" title="ARC实现"></a>ARC实现</h2><ul><li><strong>__strong：</strong>表示对对象的“强引用”。引用计数为1。持有强引用的变量，在超出其作用域时强引用失效，所以自动地释放自己持有的对象，对象的所有者不存在，因此废弃该对象。该修饰符是 id 类型和对象类型默认的所有权修饰符。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id __strong obj = [[NSObject alloc] init];</span><br><span class="line"></span><br><span class="line">// 编译器的模拟代码：</span><br><span class="line">id obj = objc_msgSend(NSObject, @selector(alloc));</span><br><span class="line">objc_msgSend(obj, @selector(init));</span><br><span class="line">objc_release(obj);</span><br></pre></td></tr></table></figure><p>　　使用 alloc/new/copy/mutableCopy 以外的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ (id)array &#123;</span><br><span class="line">    return [[NSMutableArray alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">// NSMutableArray 类的 array 类方法 通过编译器转换后的模拟代码：</span><br><span class="line">+ (id)array &#123;</span><br><span class="line">    id obj = objc_msgSend(NSMutableArray, @selector(alloc));</span><br><span class="line">    objc_msgSend(obj, @selector(init));</span><br><span class="line">    return objc_autoreleaseReturnValue(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id __strong obj = [NSMutableArray array];</span><br><span class="line">// 编译器的模拟代码：</span><br><span class="line">id obj = objc_msgSend(NSMutableArray, @selector(array));</span><br><span class="line">objc_retainAutoreleasedReturnValue(obj)</span><br><span class="line">objc_release(obj);</span><br></pre></td></tr></table></figure><p>　　objc_autoreleaseReturnValue() 函数会检查使用该函数的方法或者函数调用方的执行命令列表，如果方法或者函数的调用方调用了方法或者函数后紧接着调用 objc_retainAutoreleasedReturnValue() 函数，那么就不将返回的对象注册到 autoreleasepool 中，而是直接传递到方法或者函数的调用方。<br>而返回的对象则存储在 TLS 中， Thread Local Storage（TLS）线程局部存储，目的很简单，将一块内存作为某个线程专有的存储，以 key-value 的形式进行读写。在返回的对象身上调用 objc_autoreleaseReturnValue() 方法时， runtime 将这个返回的对象 obj 储存在 TLS 中，然后直接返回这个 obj （不调用autorelease）；同时，在外部接收这个返回的对象的方法 objc_retainAutoreleasedReturnValue() 里发现 TLS 中正好存了这个对象，那么直接返回这个 obj （不调用retain）。于是乎，调用方和被调方利用 TLS 做中转，很有默契的免去了对返回值的内存管理。这就是在ARC下，runtime 对 autorelease 返回值的优化策略。</p><blockquote><p>Thread-local storage（线程局部存储）指向 hot page ，即最新添加的 autoreleased 对象所在的那个 page 。???</p></blockquote><ul><li><strong>__weak：</strong> 表示对对象的“弱引用”。弱引用并不持有对象，不会改变赋值给附有 __weak 修饰符的变量的引用计数。持有弱引用的变量，在超出其作用域时，对象即被释放。在持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效且被赋值为 nil (空弱引用)。<strong>使用</strong> __weak 修饰符的变量，即是使用注册到 autoreleasepool 中的对象，该对象的引用计数会加1。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">id __strong obj = [[NSObject alloc] init];</span><br><span class="line"></span><br><span class="line">id __weak obj1 = obj;</span><br><span class="line">NSLog(@&quot;%@&quot;, obj1);</span><br><span class="line"></span><br><span class="line">// 编译器的模拟代码：</span><br><span class="line">id obj1;</span><br><span class="line">objc_initWeak(&amp;obj1, obj);</span><br><span class="line">id tmp = objc_loadWeakRetained(&amp;obj1);</span><br><span class="line">objc_autorelease(tmp);</span><br><span class="line">NSLog(@&quot;%@&quot;, tmp);</span><br><span class="line">objc_destroyWeak(&amp;obj1);</span><br><span class="line"></span><br><span class="line">id objc_initWeak(id *location, id newObj) &#123;</span><br><span class="line">    return storeWeak(location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void objc_destroyWeak(id *location) &#123;</span><br><span class="line">    (void)storeWeak(location, nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　storeWeak() 函数把第二参数的赋值对象的地址作为键值key，将第一参数的附有 __weak 修饰符的变量的地址作为键值 value 注册到 __weak 表中。如果第二参数(key)为 nil， 则把变量的地址(value)从 weak 表中删除。</p><p>　　weak 表与引用计数表相同，作为散列表被实现。如果使用 weak 表，将废弃对象的地址作为键值key进行检索，就能高速地获取对应的附有 __weak 修饰符的变量的地址。另外，由于一个对象可同时赋值给多个附有 __weak 修饰符的变量中，所以对于一个键值key，可注册多个变量的地址。<br>　　<br>　　objc_loadWeakRetained() 函数取出附有 __weak 修饰符变量所引用的对象并 retain。objc_autorelease() 函数将对象注册到 autoreleasepool 中 。如果大量使用附有 __weak修饰符的变量，注册到 autoreleasepool 中的对象也会大量的增加，因此在使用附有 __weak修饰符的变量时，最好先暂时赋值给附有 __strong 修饰符的变量后使用。</p><blockquote><p>对象废弃执行的动作</p></blockquote><ol><li>objc_release</li><li>当引用计数为0执行dealloc</li><li>_objc_rootDealloc</li><li>object_dispose</li><li>objc_destructInstance</li><li>objc_clear_deallocating</li></ol><blockquote><p>对象被弃用时最后调用objc_clear_deallocating 函数执行的动作</p></blockquote><ol><li>从 weak 表中获取废弃对象的地址为键值key的记录</li><li>将包含在记录中的所有附有 __weak 修饰符变量的地址，赋值为 nil </li><li>从weak 表中删除该记录</li><li>从引用计数表中删除废弃对象的地址为键值的记录</li></ol><p>　　如果大量使用附有 __weak 修饰符的变量，则会消耗相应的CPU资源，良策是只在需要避免循环引用时使用 __weak 修饰符。</p><ul><li><p><strong>__unsafe_unretained：</strong> 附有该修饰符的变量不属于编译器的内存管理对象。既不持有对象的强引用也不持有对象的弱引用，只是表示对象，若该对象被废弃，其为悬垂指针。</p></li><li><p><strong>__autoreleasing：</strong> 将对象赋值给有 __autoreleasing 修饰符的变量，等同于 ARC 无效时调用对象 autorelease 方法，会将对象注册到 autoreleasepool 中，对象的引用计数加1。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">    id __autoreleasing obj = [[NSObject alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">/* 编译器的模拟代码 */</span><br><span class="line">id pool = objc_autoreleasePoolPush();</span><br><span class="line">id obj = objc_msgSend(NSObject, @selector(alloc));</span><br><span class="line">objc_msgSend(obj, @selector(init));</span><br><span class="line">objc_autorelease(obj);</span><br><span class="line">objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">    id __autoreleasing obj = [NSMutableArray array];</span><br><span class="line">&#125;</span><br><span class="line">// 编译器的模拟代码：</span><br><span class="line">id pool = objc_autoreleasePoolPush();</span><br><span class="line">id obj = objc_msgSend(NSMutableArray, @selector(array));</span><br><span class="line">objc_retainAutoreleasedReturnValue(obj);</span><br><span class="line">objc_autorelease(obj);</span><br><span class="line">objc_autoreleasePoolPop(pool);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ARC概述&quot;&gt;&lt;a href=&quot;#ARC概述&quot; class=&quot;headerlink&quot; title=&quot;ARC概述&quot;&gt;&lt;/a&gt;ARC概述&lt;/h2&gt;&lt;p&gt;　　在Objective-C中采用Automatic Reference Counting(ARC)机制，让编译器(
      
    
    </summary>
    
      <category term="Objective-C" scheme="http://blog.lzxy169.com/categories/Objective-C/"/>
    
    
      <category term="c" scheme="http://blog.lzxy169.com/tags/c/"/>
    
      <category term="c++" scheme="http://blog.lzxy169.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>C/C++内存管理</title>
    <link href="http://blog.lzxy169.com/2018/04/13/c:c++-memory-management/"/>
    <id>http://blog.lzxy169.com/2018/04/13/c:c++-memory-management/</id>
    <published>2018-04-13T03:33:58.000Z</published>
    <updated>2018-04-18T15:24:45.791Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>　　在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。</p><ol><li><p><strong>栈：</strong>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p></li><li><p><strong>堆：</strong>就是那些由new分配的内存块，它们的释放编译器不去管，由应用程序去控制，一般一个new就要对应一个delete。如果没有手动释放掉，那么在程序结束后，操作系统会自动回收。</p></li><li><p><strong>自由存储区：</strong>就是那些由malloc等分配的内存块，它和堆是十分相似的，不过它是用free来结束自己的生命的。</p></li><li><p><strong>全局静态存储区：</strong>全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。</p></li><li><p><strong>常量存储区：</strong>这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。</p></li></ol><blockquote><p>明确区分堆与栈</p></blockquote><p>举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; </span><br><span class="line">    <span class="keyword">delete</span> []p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　这条短短的一句话就包含了堆与栈，看到new，我们首先就应该想到，我们分配了一块堆内存，那么指针p呢？他分配的是一块栈内存。<br>　　所以这行代码的意思就是：在栈内存中存放了一个指向一块堆内存的指针p。在程序会先确定在堆中分配内存的大小，然后调用operator new分配内存，然后返回这块内存的首地址，放入栈中。delete []p，这是为了告诉编译器：我删除的是一个数组，编译器就会根据相应的Cookie信息去进行释放内存的工作。</p><h3 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h3><ol><li><p><strong>管理方式：</strong>对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。</p></li><li><p><strong>空间大小：</strong>一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，一般系统默认设置栈段为8M、4M、2M或1M。</p></li><li><p><strong>碎片问题：</strong>对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。</p></li><li><p><strong>生长方向：</strong>对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。</p></li><li><p><strong>分配方式：</strong>堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloc函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p></li><li><p><strong>分配效率：</strong>栈是系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。<br>　　从这里我们可以看到，堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。</p></li></ol><p>　　虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。<br>　　无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果,就算是在你的程序运行过程中，没有发生上面的问题，你还是要小心，说不定什么时候就崩掉，那时候debug可是相当困难的：）</p><h3 id="控制C-的内存分配"><a href="#控制C-的内存分配" class="headerlink" title="控制C++的内存分配"></a>控制C++的内存分配</h3><p>　　在嵌入式系统中使用C++的一个常见问题是内存分配，即对new 和 delete 操作符的失控。<br>　　具有讽刺意味的是，问题的根源却是C++对内存的管理非常的容易而且安全。具体地说，当一个对象被消除时，它的析构函数能够安全的释放所分配的内存。<br>　　这当然是个好事情，但是这种使用的简单性使得程序员们过度使用new 和 delete，而不注意在嵌入式C++环境中的因果关系。并且，在嵌入式系统中，由于内存的限制，频繁的动态分配不定大小的内存会引起很大的问题以及堆破碎的风险。<br>　　作为忠告，保守的使用内存分配是嵌入式环境中的第一原则。<br>　　但当你必须要使用new和delete时，你不得不控制C++中的内存分配。你需要用一个全局的new 和delete来代替系统的内存分配符，并且一个类一个类的重载new和delete。<br>　　一个防止堆破碎的通用方法是从不同固定大小的内存池中分配不同类型的对象。对每个类重载new 和delete就提供了这样的控制。</p><h4 id="重载全局的new和delete操作符"><a href="#重载全局的new和delete操作符" class="headerlink" title="重载全局的new和delete操作符"></a>重载全局的new和delete操作符</h4><p>　　可以很容易地重载new 和 delete 操作符，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">return</span> (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　这段代码可以代替默认的操作符来满足内存分配的请求。出于解释C++的目的，我们也可以直接调用malloc() 和free()。<br>　　也可以对单个类的new 和 delete操作符重载。这是你能灵活的控制对象的内存分配。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line">    <span class="comment">// .. other members here ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> *TestClass::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); <span class="comment">// Replace this with alternative allocator</span></span><br><span class="line">    <span class="keyword">return</span> (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> TestClass::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">// Replace this with alternative de-allocator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　所有TestClass 对象的内存分配都采用这段代码。更进一步，任何从TestClass 继承的类也都采用这一方式，除非它自己也重载了new 和 delete 操作符。通过重载new 和 delete 操作符的方法，你可以自由地采用不同的分配策略，从不同的内存池中分配不同的类对象。</p><h4 id="为单个的类重载new-和delete"><a href="#为单个的类重载new-和delete" class="headerlink" title="为单个的类重载new[]和delete[]"></a>为单个的类重载new[]和delete[]</h4><p>　　必须小心对象数组的分配。你可能希望调用到被你重载过的new 和 delete 操作符，但并不如此。内存的请求被定向到全局的new[]和delete[] 操作符，而这些内存来自于系统堆。<br>　　C++将对象数组的内存分配作为一个单独的操作，而不同于单个对象的内存分配。为了改变这种方式，你同样需要重载new[] 和 delete[]操作符。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[ ](<span class="keyword">size_t</span> size);</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[ ](<span class="keyword">void</span> *p);</span><br><span class="line">    <span class="comment">// .. other members here ..</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> *TestClass::<span class="keyword">operator</span> <span class="keyword">new</span>[ ](<span class="keyword">size_t</span> size)&#123;</span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">return</span> (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> TestClass::<span class="keyword">operator</span> <span class="keyword">delete</span>[ ](<span class="keyword">void</span> *p)&#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    TestClass *p = <span class="keyword">new</span> TestClass[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// ... etc ...</span></span><br><span class="line">    <span class="keyword">delete</span>[ ] p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　但是注意：对于多数C++的实现，new[]操作符中的个数参数是数组的大小加上额外的存储对象数目的一些字节。在你的内存分配机制重要考虑的这一点。你应该尽量避免分配对象数组，从而使你的内存分配策略简单。</p><h3 id="常见的内存错误及其对策"><a href="#常见的内存错误及其对策" class="headerlink" title="常见的内存错误及其对策"></a>常见的内存错误及其对策</h3><p>　　发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行时才能捕捉到。而这些错误大多没有明显的症状，时隐时现，增加了改错的难度。</p><blockquote><p>常见的内存错误及其对策如下：</p></blockquote><ol><li><strong>内存分配未成功，却使用了它。</strong>编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。</li><li><strong>内存分配虽然成功，但是尚未初始化就引用它。</strong>犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。</li><li><strong>内存分配成功并且已经初始化，但操作越过了内存的边界。</strong>例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。</li><li><strong>忘记了释放内存，造成内存泄露。</strong>含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。</li><li><strong>释放了内存却继续使用它。</strong> 有三种情况：<br>(1). 程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。<br>(2). 函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。<br>(3). 使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。</li></ol><blockquote><p>那么如何避免产生野指针呢？这里列出了5条规则，平常写程序时多注意一下，养成良好的习惯。</p></blockquote><p><strong><em>　　规则1：用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。<br>　　规则2：不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。<br>　　规则3：避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。<br>　　规则4：动态内存的申请与释放必须配对，防止内存泄漏。<br>　　规则5：用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。</em></strong></p><h3 id="指针与数组的对比"><a href="#指针与数组的对比" class="headerlink" title="指针与数组的对比"></a>指针与数组的对比</h3><p>　　C++/C程序中，指针和数组在不少地方可以相互替换着用，让人产生一种错觉，以为两者是等价的。<br>　　<strong>数组：</strong>要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（而不是指向）一块内存，其地址与容量在生命期内保持不变，只有数组的内容可以改变。<br>　　<strong>指针：</strong>可以随时指向任意类型的内存块，它的特征是“可变”，所以我们常用指针来操作动态内存。指针远比数组灵活，但也更危险。　　</p><blockquote><p>下面以字符串为例比较指针与数组的特性。</p></blockquote><ol><li><p><strong>修改内容</strong><br>　　下面示例中，字符数组a的容量是6个字符，其内容为 hello。a的内容可以改变，如a[0]= ‘X’。指针p指向常量字符串“world”（位于静态存储区，内容为world），常量字符串的内容是不可以被修改的。从语法上看，编译器并不觉得语句p[0]= ‘X’有什么不妥，但是该语句企图修改常量字符串的内容而导致运行错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = “hello”;</span><br><span class="line">a[<span class="number">0</span>] = ‘X’;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">char</span> *p = “world”; <span class="comment">// 注意p指向常量字符串</span></span><br><span class="line">p[<span class="number">0</span>] = ‘X’; <span class="comment">// 编译器不能发现该错误</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>内容复制与比较</strong><br>　　不能对数组名进行直接复制与比较。若想把数组a的内容复制给数组b，不能用语句 b = a ，否则将产生编译错误。应该用标准库函数strcpy进行复制。同理，比较b和a的内容是否相同，不能用if(b==a) 来判断，应该用标准库函数strcmp进行比较。<br>　　语句 p = a 并不能把a的内容复制给指针p，而是把a的地址赋给了p。要想复制a的内容，可以先用库函数malloc为p申请一块容量为strlen(a)+1个字符的内存，再用strcpy进行字符串复制。同理，语句if(p==a) 比较的不是内容而是地址，应该用库函数strcmp来比较。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组…</span></span><br><span class="line"><span class="keyword">char</span> a[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> b[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(b, a); <span class="comment">// 不能用 b = a;</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(b, a) == <span class="number">0</span>) <span class="comment">// 不能用 if (b == a)</span></span><br><span class="line">…</span><br><span class="line"><span class="comment">// 指针…</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(a);</span><br><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*(len+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">strcpy</span>(p,a); <span class="comment">// 不要用 p = a;</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(p, a) == <span class="number">0</span>) <span class="comment">// 不要用 if (p == a)</span></span><br><span class="line">…</span><br></pre></td></tr></table></figure></li><li><p><strong>计算内存容量</strong><br>　　用运算符sizeof可以计算出数组的容量（字节数）。如下示例中，sizeof(a)的值是12。指针p指向a，但是sizeof(p)的值却是4。这是因为sizeof(p)得到的是一个指针变量的字节数，相当于sizeof(char*)，而不是p所指的内存容量。C++/C语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = a;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 12字节</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(p) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4字节</span></span><br></pre></td></tr></table></figure></li></ol><p>　　注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。如下示例中，不论数组a的容量是多少，sizeof(a)始终等于sizeof(char *)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">char</span> a[<span class="number">100</span>])</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4字节而不是100字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="指针参数是如何传递内存的"><a href="#指针参数是如何传递内存的" class="headerlink" title="指针参数是如何传递内存的"></a>指针参数是如何传递内存的</h3><p>　　如果函数的参数是一个指针，不要指望用该指针去申请动态内存。如下示例中，Test函数的语句GetMemory(str, 200)并没有使str获得期望的内存，str依旧是NULL，为什么？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">(<span class="keyword">char</span> *p, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    GetMemory(str, <span class="number">100</span>); <span class="comment">// str 仍然为 NULL</span></span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">"hello"</span>); <span class="comment">// 运行错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　毛病出在函数GetMemory中。编译器总是要为函数的每个参数制作临时副本，指针参数p的副本是 _p，编译器使 _p=p。如果函数体内的程序修改了_p的内容，就导致参数p的内容作相应的修改。这就是指针可以用作输出参数的原因。在本例中，_p申请了新的内存，只是把 _p所指的内存地址改变了，但是p丝毫未变。所以函数GetMemory并不能输出任何东西。事实上，每执行一次GetMemory就会泄露一块内存，因为没有用free释放内存。<br>　　如果非得要用指针参数去申请内存，那么应该改用“指向指针的指针”，见示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory2</span><span class="params">(<span class="keyword">char</span> **p, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    GetMemory2(&amp;str, <span class="number">100</span>); <span class="comment">// 注意参数是 &amp;str，而不是str</span></span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">"hello"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　由于“指向指针的指针”这个概念不容易理解，我们可以用函数返回值来传递动态内存。这种方法更加简单，见示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetMemory3</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    str = GetMemory3(<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">"hello"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　用函数返回值来传递动态内存这种方法虽然好用，但是常常有人把return语句用错了。这里强调不要用return语句返回指向“栈内存”的指针，因为该内存在函数结束时自动消亡，见示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetString</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> p[] = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">// 编译器将提出警告</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test4</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    str = GetString(); <span class="comment">// str 的内容是垃圾</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　用调试器逐步跟踪Test4，发现执行str = GetString语句后str不再是NULL指针，但是str的内容不是“hello world”而是垃圾。<br>　　如果把上述示例改写成如下示例，会怎么样？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetString2</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test5</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    str = GetString2();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　函数Test5运行虽然不会出错，但是函数GetString2的设计概念却是错误的。因为GetString2内的“hello world”是常量字符串，位于静态存储区，它在程序生命期内恒定不变。无论什么时候调用GetString2，它返回的始终是同一个“只读”的内存块。</p><h3 id="杜绝“野指针”"><a href="#杜绝“野指针”" class="headerlink" title="杜绝“野指针”"></a>杜绝“野指针”</h3><p>　　“野指针”不是NULL指针，是指向“垃圾”内存的指针。人们一般不会错用NULL指针，因为用if语句很容易判断。但是“野指针”是很危险的，if语句对它不起作用。 “野指针”的成因主要有三种：</p><ol><li><p><strong>指针变量没有被初始化</strong>。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">char</span> *str = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。</strong></p></li><li><strong>指针操作超越了变量的作用域范围。</strong> 这种情况让人防不胜防，示例程序如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; “Func of <span class="class"><span class="keyword">class</span> <span class="title">A</span>” &lt;&lt; endl; &#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class">void Test(void)&#123;</span></span><br><span class="line"><span class="class">    A *p;</span></span><br><span class="line"><span class="class">    A a; </span></span><br><span class="line"><span class="class">    p = &amp;a; // 注意 a 的生命期</span></span><br><span class="line"><span class="class">    p-&gt;Func(); // p是“野指针”</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><p>　　函数Test在执行语句p-&gt;Func()时，对象a已经消失，而p是指向a的，所以p就成了“野指针”。但奇怪的是我运行这个程序时居然没有出错，这可能与编译器有关。</p><h3 id="有了malloc-free为什么还要new-delete"><a href="#有了malloc-free为什么还要new-delete" class="headerlink" title="有了malloc/free为什么还要new/delete"></a>有了malloc/free为什么还要new/delete</h3><p>　　malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。<br>　　对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。<br>　　因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。我们先看一看malloc/free和new/delete如何实现对象的动态内存管理，见示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">　　Obj(<span class="keyword">void</span>)&#123; <span class="built_in">cout</span> &lt;&lt; “Initialization” &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">　　~Obj(<span class="keyword">void</span>)&#123; <span class="built_in">cout</span> &lt;&lt; “Destroy” &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">　　<span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; “Initialization” &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">　　<span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; “Destroy” &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseMallocFree</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    Obj *a = (obj *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(obj)); <span class="comment">// 申请动态内存</span></span><br><span class="line">    a-&gt;Initialize(); <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">    a-&gt;Destroy(); <span class="comment">// 清除工作</span></span><br><span class="line">    <span class="built_in">free</span>(a); <span class="comment">// 释放内存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseNewDelete</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    Obj *a = <span class="keyword">new</span> Obj; <span class="comment">// 申请动态内存并且初始化</span></span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">    <span class="keyword">delete</span> a; <span class="comment">// 清除并且释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　类Obj的函数Initialize模拟了构造函数的功能，函数Destroy模拟了析构函数的功能。函数UseMallocFree中，由于malloc/free不能执行构造函数与析构函数，必须调用成员函数Initialize和Destroy来完成初始化与清除工作。函数UseNewDelete则简单得多。<br>　　所以我们不要企图用malloc/free来完成动态对象的内存管理，应该用new/delete。由于内部数据类型的“对象”没有构造与析构的过程，对它们而言malloc/free和new/delete是等价的。<br>　　既然new/delete的功能完全覆盖了malloc/free，为什么C++不把malloc/free淘汰出局呢？这是因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。<br>　　如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，结果也会导致程序出错，但是该程序的可读性很差。所以new/delete必须配对使用，malloc/free也一样。</p><h3 id="内存耗尽怎么办"><a href="#内存耗尽怎么办" class="headerlink" title="内存耗尽怎么办"></a>内存耗尽怎么办</h3><p>　　如果在申请动态内存时找不到足够大的内存块，malloc和new将返回NULL指针，宣告内存申请失败。通常有三种方式处理“内存耗尽”问题。</p><ol><li><p><strong>判断指针是否为NULL，如果是则马上用return语句终止本函数。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> A;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>判断指针是否为NULL，如果是则马上用exit(1)终止整个程序的运行。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> A;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; “Memory Exhausted” &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>为new和malloc设置异常处理函数。</strong><br>　　Visual C++可以用_set_new_hander函数为new设置用户自己定义的异常处理函数，也可以让malloc享用与new相同的异常处理函数。详细内容请参考C++使用手册。<br>　　上述 1、2 方式使用最普遍。如果一个函数内有多处需要申请动态内存，那么方式 1 就显得力不从心（释放内存很麻烦），应该用方式 2 来处理。<br>　　很多人不忍心用exit(1)，问：“不编写出错处理程序，让操作系统自己解决行不行？”<br>　　不行。如果发生“内存耗尽”这样的事情，一般说来应用程序已经无药可救。如果不用exit(1) 把坏程序杀死，它可能会害死操作系统。道理如同：如果不把歹徒击毙，歹徒在老死之前会犯下更多的罪。<br>　　有一个很重要的现象要告诉大家。对于32位以上的应用程序而言，无论怎样使用malloc与new，几乎不可能导致“内存耗尽”。对于32位以上的应用程序，“内存耗尽”错误处理程序毫无用处。这下可把Unix和Windows程序员们乐坏了：反正错误处理程序不起作用，我就不写了，省了很多麻烦。</p></li></ol><blockquote><p>必须强调：不加错误处理将导致程序的质量很差，千万不可因小失大。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">1000000</span>];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; “eat memory” &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="malloc-free的使用要点"><a href="#malloc-free的使用要点" class="headerlink" title="malloc/free的使用要点　"></a>malloc/free的使用要点　</h3><p>函数malloc的原型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure></p><p>　　用malloc申请一块长度为length的整数类型的内存，程序如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * length);</span><br></pre></td></tr></table></figure></p><p>　　我们应当把注意力集中在两个要素上：“类型转换”和“sizeof”。<br>　　malloc返回值的类型是void *，所以在调用malloc时要显式地进行类型转换，将void *转换成所需要的指针类型。<br>　　malloc函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。我们通常记不住int, float等数据类型的变量的确切字节数。例如int变量在16位系统下是2个字节，在32位下是4个字节；而float变量在16位系统下是4个字节，在32位下也是4个字节。最好用以下程序作一次测试：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">float</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">double</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">void</span> *) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>　　在malloc的“()”中使用sizeof运算符是良好的风格，但要当心有时我们会昏了头，写出 p = malloc(sizeof(p))这样的程序来。<br>　　函数free的原型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">( <span class="keyword">void</span> * memblock )</span></span>;</span><br></pre></td></tr></table></figure></p><p>　　为什么free函数不象malloc函数那样复杂呢？这是因为指针p的类型以及它所指的内存的容量事先都是知道的，语句free(p)能正确地释放内存。如果p是NULL指针，那么free对p无论操作多少次都不会出问题。如果p不是NULL指针，那么free对p连续操作两次就会导致程序运行错误。</p><h3 id="new-delete的使用要点"><a href="#new-delete的使用要点" class="headerlink" title="new/delete的使用要点"></a>new/delete的使用要点</h3><p>　　运算符new使用起来要比函数malloc简单得多，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * length);</span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br></pre></td></tr></table></figure></p><p>　　这是因为new内置了sizeof、类型转换和类型安全检查功能。对于非内部数据类型的对象而言，new在创建动态对象的同时完成了初始化工作。如果对象有多个构造函数，那么new的语句也可以有多种形式。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">    Obj(<span class="keyword">void</span>); <span class="comment">// 无参数的构造函数</span></span><br><span class="line">    Obj(<span class="keyword">int</span> x); <span class="comment">// 带一个参数的构造函数</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    Obj *a = <span class="keyword">new</span> Obj;</span><br><span class="line">    Obj *b = <span class="keyword">new</span> Obj(<span class="number">1</span>); <span class="comment">// 初值为1</span></span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　如果用new创建对象数组，那么只能使用对象的无参数构造函数。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Obj *objects = <span class="keyword">new</span> Obj[<span class="number">100</span>]; <span class="comment">// 创建100个动态对象</span></span><br></pre></td></tr></table></figure></p><p>　　不能写成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Obj *objects = <span class="keyword">new</span> Obj[<span class="number">100</span>](<span class="number">1</span>);<span class="comment">// 创建100个动态对象的同时赋初值1</span></span><br></pre></td></tr></table></figure></p><p>　　在用delete释放对象数组时，留意不要丢了符号‘[]’。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> []objects; <span class="comment">// 正确的用法</span></span><br><span class="line"><span class="keyword">delete</span> objects; <span class="comment">// 错误的用法</span></span><br></pre></td></tr></table></figure></p><p>　　后者有可能引起程序崩溃和内存泄漏。</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;内存分配&quot;&gt;&lt;a href=&quot;#内存分配&quot; class=&quot;headerlink&quot; title=&quot;内存分配&quot;&gt;&lt;/a&gt;内存分配&lt;/h3&gt;&lt;p&gt;　　在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p
      
    
    </summary>
    
      <category term="C/C++" scheme="http://blog.lzxy169.com/categories/C-C/"/>
    
    
      <category term="c" scheme="http://blog.lzxy169.com/tags/c/"/>
    
      <category term="c++" scheme="http://blog.lzxy169.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>算法之查找</title>
    <link href="http://blog.lzxy169.com/2018/04/10/algorithm-search/"/>
    <id>http://blog.lzxy169.com/2018/04/10/algorithm-search/</id>
    <published>2018-04-10T04:25:58.000Z</published>
    <updated>2018-07-30T12:42:46.121Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="1. 顺序查找"></a>1. 顺序查找</h3><p><strong>说明：</strong><br>顺序查找适合于存储结构为顺序存储或链接存储的线性表。</p><p><strong>基本思想：</strong><br>顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。</p><p><strong>复杂度分析：</strong><br>查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL = 1/n(1+2+3+…+n) = (n+1)/2 ;<br>当查找不成功时，需要n+1次比较，时间复杂度为O(n); 所以，顺序查找的时间复杂度为O(n)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//顺序查找</span><br><span class="line">int SequenceSearch(int a[], int value, int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0; i&lt;n; i++)</span><br><span class="line">        if(a[i]==value)</span><br><span class="line">            return i;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2. 二分查找"></a>2. 二分查找</h3><p><strong>说明：</strong><br>元素必须是有序的，如果是无序的则要先进行排序操作。</p><p><strong>基本思想：</strong><br>也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。</p><p><strong>复杂度分析：</strong><br>最坏情况下，关键词比较次数为$log_2 (n+1)$，且期望时间复杂度为O($log_2 n$)；$log_2 x$<br>注：折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//二分查找（折半查找），版本1</span><br><span class="line">int BinarySearch1(int a[], int value, int n)</span><br><span class="line">&#123;</span><br><span class="line">    int low, high, mid;</span><br><span class="line">    low = 0;</span><br><span class="line">    high = n-1;</span><br><span class="line">    while(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low+high)/2;</span><br><span class="line">        if(a[mid]==value)</span><br><span class="line">            return mid;</span><br><span class="line">        if(a[mid]&gt;value)</span><br><span class="line">            high = mid-1;</span><br><span class="line">        if(a[mid]&lt;value)</span><br><span class="line">            low = mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//二分查找，递归版本</span><br><span class="line">int BinarySearch2(int a[], int value, int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">    int mid = low+(high-low)/2;</span><br><span class="line">    if(a[mid]==value)</span><br><span class="line">        return mid;</span><br><span class="line">    if(a[mid]&gt;value)</span><br><span class="line">        return BinarySearch2(a, value, low, mid-1);</span><br><span class="line">    if(a[mid]&lt;value)</span><br><span class="line">        return BinarySearch2(a, value, mid+1, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-插值查找"><a href="#3-插值查找" class="headerlink" title="3. 插值查找"></a>3. 插值查找</h3><p><strong>说明：</strong><br>在介绍插值查找之前，首先考虑一个新问题，为什么上述算法一定要是折半，而不是折四分之一或者折更多呢？打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是一定目的的往前或往后翻。同样的，比如要在取值范围1 ~ 10000 之间 100 个元素从小到大均匀分布的数组中查找5，我们自然会考虑从数组下标较小的开始查找。经过以上分析，折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。二分查找中查找点计算如下：mid=(low+high)/2, 即mid=low+1/2<em>(high-low);通过类比，我们可以将查找的点改进为如下：mid=low+(key-a[low])/(a[high]-a[low])</em>(high-low)也就是将上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。</p><p><strong>基本思想：</strong><br>基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。<br>注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</p><p><strong>复杂度分析：</strong><br>查找成功或者失败的时间复杂度均为O(log2(log2n))。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//插值查找</span><br><span class="line">int InsertionSearch(int a[], int value, int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">    int mid = low+(value-a[low])/(a[high]-a[low])*(high-low);</span><br><span class="line">    if(a[mid]==value)</span><br><span class="line">        return mid;</span><br><span class="line">    if(a[mid]&gt;value)</span><br><span class="line">        return InsertionSearch(a, value, low, mid-1);</span><br><span class="line">    if(a[mid]&lt;value)</span><br><span class="line">        return InsertionSearch(a, value, mid+1, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-斐波那契查找"><a href="#4-斐波那契查找" class="headerlink" title="4. 斐波那契查找"></a>4. 斐波那契查找</h3><p><strong>说明：</strong><br>在介绍斐波那契查找算法之前，我们先介绍一下很它紧密相连并且大家都熟知的一个概念——黄金分割。黄金比例又称黄金分割，是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为1:0.618或1.618:1。</p><p><strong>基本思想：</strong><br>也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。<br>相对于折半查找，一般将待比较的key值与第mid=（low+high）/2位置的元素比较，比较结果分三种情况：<br>1）相等，mid位置的元素即为所求<br>2）&gt;，low=mid+1;<br>3）&lt;，high=mid-1。<br>斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。他要求开始表中记录的个数为某个斐波那契数小1，及n=F(k)-1;<br>开始将k值与第F(k-1)位置的记录进行比较(及mid=low+F(k-1)-1),比较结果也分为三种<br>1）相等，mid位置的元素即为所求<br>2）&gt;，low=mid+1,k-=2;<br>说明：low=mid+1说明待查找的元素在[mid+1,high]范围内，k-=2 说明范围[mid+1,high]内的元素个数为n-(F(k-1))= Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个，所以可以递归的应用斐波那契查找。<br>3）&lt;，high=mid-1,k-=1。<br>说明：low=mid+1说明待查找的元素在[low,mid-1]范围内，k-=1 说明范围[low,mid-1]内的元素个数为F(k-1)-1个，所以可以递归 的应用斐波那契查找。</p><p><strong>复杂度分析：</strong><br>最坏情况下，时间复杂度为O(log2n)，且其期望复杂度也为O(log2n)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">// 斐波那契查找.cpp </span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include  &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int max_size=20;//斐波那契数组的长度</span><br><span class="line"></span><br><span class="line">/*构造一个斐波那契数组*/ </span><br><span class="line">void Fibonacci(int * F)</span><br><span class="line">&#123;</span><br><span class="line">    F[0]=0;</span><br><span class="line">    F[1]=1;</span><br><span class="line">    for(int i=2;i&lt;max_size;++i)</span><br><span class="line">        F[i]=F[i-1]+F[i-2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*定义斐波那契查找法*/  </span><br><span class="line">int FibonacciSearch(int *a, int n, int key)  //a为要查找的数组,n为要查找的数组长度,key为要查找的关键字</span><br><span class="line">&#123;</span><br><span class="line">  int low=0;</span><br><span class="line">  int high=n-1;</span><br><span class="line">  </span><br><span class="line">  int F[max_size];</span><br><span class="line">  Fibonacci(F);//构造一个斐波那契数组F </span><br><span class="line"></span><br><span class="line">  int k=0;</span><br><span class="line">  while(n&gt;F[k]-1)//计算n位于斐波那契数列的位置</span><br><span class="line">      ++k;</span><br><span class="line"></span><br><span class="line">  int  * temp;//将数组a扩展到F[k]-1的长度</span><br><span class="line">  temp=new int [F[k]-1];</span><br><span class="line">  memcpy(temp,a,n*sizeof(int));</span><br><span class="line"></span><br><span class="line">  for(int i=n;i&lt;F[k]-1;++i)</span><br><span class="line">     temp[i]=a[n-1];</span><br><span class="line">  </span><br><span class="line">  while(low&lt;=high)</span><br><span class="line">  &#123;</span><br><span class="line">    int mid=low+F[k-1]-1;</span><br><span class="line">    if(key&lt;temp[mid])</span><br><span class="line">    &#123;</span><br><span class="line">      high=mid-1;</span><br><span class="line">      k-=1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(key&gt;temp[mid])</span><br><span class="line">    &#123;</span><br><span class="line">     low=mid+1;</span><br><span class="line">     k-=2;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">       if(mid&lt;n)</span><br><span class="line">           return mid; //若相等则说明mid即为查找到的位置</span><br><span class="line">       else</span><br><span class="line">           return n-1; //若mid&gt;=n则说明是扩展的数值,返回n-1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  delete [] temp;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[] = &#123;0,16,24,35,47,59,62,73,88,99&#125;;</span><br><span class="line">    int key=100;</span><br><span class="line">    int index=FibonacciSearch(a,sizeof(a)/sizeof(int),key);</span><br><span class="line">    cout&lt;&lt;key&lt;&lt;&quot; is located at:&quot;&lt;&lt;index;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5-树表查找"><a href="#5-树表查找" class="headerlink" title="5. 树表查找"></a>5. 树表查找</h3><p><strong>说明：</strong><br><strong>5.1 最简单的树表查找算法——二叉树查找算法。</strong></p><p><strong>基本思想：</strong><br>二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。<br>二叉查找树（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree）或者是一棵空树，或者是具有下列性质的二叉树：<br>　　1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>　　2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>　　3）任意节点的左、右子树也分别为二叉查找树。<br>二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。<br>有关二叉查找树的查找、插入、删除等操作的详细讲解，请移步浅谈算法和数据结构:  <a href="http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html" target="_blank" rel="noopener">二叉查找树</a></p><p><strong>复杂度分析：</strong><br>它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行n次查找操作）。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。<br>基于二叉查找树进行优化，进而可以得到其他的树表查找算法，如平衡树、红黑树等高效算法。</p><p><strong>5.2 平衡查找树之2-3查找树（2-3 Tree）</strong><br>　　2-3查找树定义：和二叉树不一样，2-3树运行每个节点保存1个或者两个的值。对于普通的2节点(2-node)，他保存1个key和左右两个自己点。对应3节点(3-node)，保存两个Key，2-3查找树的定义如下：<br>　　1）要么为空，要么：<br>　　2）对于2节点，该节点保存一个key及对应value，以及两个指向左右节点的节点，左节点也是一个2-3节点，所有的值都比key要小，右节点也是一个2-3节点，所有的值比key要大。<br>　　3）对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。</p><p><strong>2-3查找树的性质：</strong><br>　　1）如果中序遍历2-3查找树，就可以得到排好序的序列；<br>　　2）在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。（这也是平衡树中“平衡”一词的概念，根节点到叶节点的最长距离对应于查找算法的最坏情况，而平衡树中根节点到叶节点的距离都一样，最坏情况也具有对数复杂度。）<br><strong>复杂度分析：</strong><br>2-3树的查找效率与树的高度是息息相关的。</p><ul><li>在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为lgN</li><li>在最好的情况下，所有的节点都是3-node节点，查找效率为log3N约等于0.631lgN, 距离来说，对于1百万个节点的2-3树，树的高度为12-20之间，对于10亿个节点的2-3树，树的高度为18-30之间。对于插入来说，只需要常数次操作即可完成，因为他只需要修改与该节点关联的节点即可，不需要检查其他节点，所以效率和查找类似。下面是2-3查找树的效率：</li></ul><p><strong>5.3 平衡查找树之红黑树（Red-Black Tree）</strong><br>　　2-3查找树能保证在插入元素之后能保持树的平衡状态，最坏情况下即所有的子节点都是2-node，树的高度为lgn，从而保证了最坏情况下的时间复杂度。但是2-3树实现起来比较复杂，于是就有了一种简单实现2-3树的数据结构，即红黑树（Red-Black Tree）。</p><p><strong>基本思想：</strong><br>红黑树的思想就是对2-3查找树进行编码，尤其是对2-3查找树中的3-nodes节点添加额外的信息。红黑树中将节点之间的链接分为两种不同类型，红色链接，他用来链接两个2-nodes节点来表示一个3-nodes节点。黑色链接用来链接普通的2-3节点。特别的，使用红色链接的两个2-nodes来表示一个3-nodes节点，并且向左倾斜，即一个2-node是另一个2-node的左子节点。这种做法的好处是查找的时候不用做任何修改，和普通的二叉查找树相同。</p><p><strong>红黑树的定义：</strong><br>红黑树是一种具有红色和黑色链接的平衡查找树，同时满足：</p><ul><li>红色节点向左倾斜</li><li>一个节点不可能有两个红色链接</li><li>整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。<br>　　下图可以看到红黑树其实是2-3树的另外一种表现形式：如果我们将红色的连线水平绘制，那么他链接的两个2-node节点就是2-3树中的一个3-node节点了。<br><strong>红黑树的性质：</strong>整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同（2-3树的第2）性质，从根节点到叶子节点的距离都相等）。<br><strong>复杂度分析：</strong>最坏的情况就是，红黑树中除了最左侧路径全部是由3-node节点组成，即红黑相间的路径长度是全黑路径长度的2倍。红黑树的平均高度大约为logn。<br>红黑树这种数据结构应用十分广泛，在多种编程语言中被用作符号表的实现，如：</li><li>Java中的java.util.TreeMap,java.util.TreeSet；</li><li>C++ STL中的：map,multimap,multiset；</li><li>.NET中的：SortedDictionary,SortedSet 等。</li></ul><p><strong>5.4 B树和B+树（B Tree/B+ Tree）</strong><br>平衡查找树中的2-3树以及其实现红黑树。2-3树种，一个节点最多有2个key，而红黑树则使用染色的方式来标识这两个key。<br>维基百科对B树的定义为“在计算机科学中，B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。</p><p><strong>B树定义：</strong><br>B树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。</p><ul><li>根节点至少有两个子节点</li><li>每个节点有M-1个key，并且以升序排列</li><li>位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间</li><li>其它节点至少有M/2个子节点<br>可以看到B树是2-3树的一种扩展，他允许一个节点有多于2个的元素。B树的插入及平衡化操作和2-3树很相似</li></ul><p><strong>B+树定义：</strong><br>B+树是对B树的一种变形树，它与B树的差异在于：</p><ul><li>有k个子结点的结点必然有k个关键码；</li><li>非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。</li><li>树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。</li></ul><p><strong>B和B+树的区别</strong><br>B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。<br><strong>B+ 树的优点在于：</strong></p><ul><li>由于B+树在内部节点上不好含数据信息，因此在内存页中能够存放更多的key。数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。</li><li>B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。<br>但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。</li></ul><p>B/B+树常用于文件系统和数据库系统中，它通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存储的空间局部性从而减少IO操作。它广泛用于文件系统及数据库中，如：</p><ul><li>Windows：HPFS文件系统；</li><li>Mac：HFS，HFS+文件系统；</li><li>Linux：ResiserFS，XFS，Ext3FS，JFS文件系统；</li><li>数据库：ORACLE，MYSQL，SQLSERVER等中。<br>有关B/B+树在数据库索引中的应用，请看<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">张洋的MySQL索引背后的数据结构及算法原理</a>这篇文章，这篇文章对MySQL中的如何使用B+树进行索引有比较详细的介绍，推荐阅读。</li></ul><p><strong>树表查找总结：</strong><br>二叉查找树平均查找性能不错，为O(logn)，但是最坏情况会退化为O(n)。在二叉查找树的基础上进行优化，我们可以使用平衡查找树。平衡查找树中的2-3查找树，这种数据结构在插入之后能够进行自平衡操作，从而保证了树的高度在一定的范围内进而能够保证最坏情况下的时间复杂度。但是2-3查找树实现起来比较困难，红黑树是2-3树的一种简单高效的实现，他巧妙地使用颜色标记来替代2-3树中比较难处理的3-node节点问题。红黑树是一种比较高效的平衡查找树，应用非常广泛，很多编程语言的内部实现都或多或少的采用了红黑树。<br>除此之外，2-3查找树的另一个扩展——B/B+平衡树，在文件系统和数据库系统中有着广泛的应用。</p><h3 id="6-分块查找"><a href="#6-分块查找" class="headerlink" title="6. 分块查找"></a>6. 分块查找</h3><p><strong>说明：</strong><br>分块查找又称索引顺序查找，它是顺序查找的一种改进方法。</p><p><strong>基本思想：</strong><br>将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，</p><p><strong>复杂度分析：</strong><br><strong>算法流程：</strong><br>　　step1 先选取各块中的最大关键字构成一个索引表；<br>　　step2 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。</p><h3 id="7-哈希查找"><a href="#7-哈希查找" class="headerlink" title="7. 哈希查找"></a>7. 哈希查找</h3><p><strong>说明：</strong><br><strong>什么是哈希表（Hash）？</strong><br>　　我们使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素”分类”，然后将这个元素存储在相应”类”所对应的地方。但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了”冲突”，换句话说，就是把不同的元素分在了相同的”类”之中。后面我们将看到一种解决”冲突”的简便做法。<br>　　总的来说，”直接定址”与”解决冲突”是哈希表的两大特点。<br><strong>什么是哈希函数？</strong><br>　　哈希函数的规则是：通过某种转换关系，使关键字适度的分散到指定大小的的顺序结构中，越分散，则以后查找的时间复杂度越小，空间复杂度越高。</p><p><strong>基本思想：</strong><br>哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。</p><p><strong>算法流程：</strong><br>1）用给定的哈希函数构造哈希表；<br>2）根据选择的冲突处理方法解决地址冲突；常见的解决冲突的方法：拉链法和线性探测法。详细的介绍可以参见：浅谈算法和数据结构: 十一 哈希表。<br>3）在哈希表的基础上执行哈希查找。哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。</p><p><strong>复杂度分析：</strong><br>单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)（注意，在查找之前我们需要构建相应的Hash表）。</p><p><strong>使用Hash，我们付出了什么？</strong><br>　　我们在实际编程中存储一个大规模的数据，最先想到的存储结构可能就是map，也就是我们常说的KV pair，经常使用Python的博友可能更有这种体会。使用map的好处就是，我们在后续处理数据处理时，可以根据数据的key快速的查找到对应的value值。map的本质就是Hash表，那我们在获取了超高查找效率的基础上，我们付出了什么？<br>　　Hash是一种典型以空间换时间的算法，比如原来一个长度为100的数组，对其查找，只需要遍历且匹配相应记录即可，从空间复杂度上来看，假如数组存储的是byte类型数据，那么该数组占用100byte空间。现在我们采用Hash算法，我们前面说的Hash必须有一个规则，约束键与存储位置的关系，那么就需要一个固定长度的hash表，此时，仍然是100byte的数组，假设我们需要的100byte用来记录键与位置的关系，那么总的空间为200byte,而且用于记录规则的表大小会根据规则，大小可能是不定的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-顺序查找&quot;&gt;&lt;a href=&quot;#1-顺序查找&quot; class=&quot;headerlink&quot; title=&quot;1. 顺序查找&quot;&gt;&lt;/a&gt;1. 顺序查找&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;br&gt;顺序查找适合于存储结构为顺序存储或链接存储的线性表。&lt;/
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://blog.lzxy169.com/categories/Algorithm/"/>
    
    
      <category term="c" scheme="http://blog.lzxy169.com/tags/c/"/>
    
      <category term="c++" scheme="http://blog.lzxy169.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>算法之排序</title>
    <link href="http://blog.lzxy169.com/2018/04/09/algorithm-sort/"/>
    <id>http://blog.lzxy169.com/2018/04/09/algorithm-sort/</id>
    <published>2018-04-09T04:25:58.000Z</published>
    <updated>2018-07-30T10:26:33.792Z</updated>
    
    <content type="html"><![CDATA[<p>排序分为内部排序和外部排序，内部排序指待排序的记录在内存中，外部排序的记录数量很大，以至于内存放不下而放在外存中，排序过程需要访问外存。这里仅介绍内部排序，包括插入排序、交换排序、选择排序、归并排序、基数排序。</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p><strong>1，直接插入排序：</strong>就是检查第i个数字，如果在它的左边的数字比它大，进行交换，这个动作一直继续下去，直到这个数字的左边数字比它还要小，就可以停止了。插入排序法主要的回圈有两个变数：i和j，每一次执行这个回圈，就会将第i个数字放到左边恰当的位置去。</p><figure class="highlight c"><figcaption><span>// 直接插入 从小到大排序</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((a[j] &gt; tmp) &amp;&amp; (j &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">            a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span>// 直接插入</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">           <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">           <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; tmp; j--) &#123;</span><br><span class="line">               a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">           &#125;</span><br><span class="line">           a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>2，折半插入排序（binary insertion sort）：</strong>当直接插入进行到某一趟时，对于a[i]来讲，前面i－1个记录已经按关键字有序。此时不用直接插入排序的方法，而改为折半查找，找出a[i]应插入的位置。</p><figure class="highlight c"><figcaption><span>// 折半插入 从小到大排序</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binaryInsertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (tmp &lt; a[middle]) &#123;</span><br><span class="line">                high = middle - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i<span class="number">-1</span>; j &gt;= low; j--) &#123;</span><br><span class="line">            a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        a[low] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3，希尔排序：</strong>“缩小增量”的排序方法，初期选用增量较大间隔比较，然后增量缩小，最后为1，希尔排序对增量序列没有严格规定。</p><figure class="highlight c"><figcaption><span>// 希尔排序 从小到大排序</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">            <span class="keyword">int</span> j = i - k;</span><br><span class="line">            <span class="keyword">while</span> ((a[j] &gt; tmp) &amp;&amp; (j &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">                a[j+k] = a[j];</span><br><span class="line">                j -= k;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j+k] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        k /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><p><strong>1，冒泡排序：</strong>面对一排数据，先从前往后两两比较，如果前一个数比后一个数大就交换两者的顺序，即第一个数和第二个数比，第二个数和第三个数比，……,倒数第二个数和最后一个数比，这样一轮下来以后最大的数就排到最后；接着把除去最大的数的该组数据进行同样的操作，直至这组数只剩下一个，排序结束。</p><figure class="highlight c"><figcaption><span>// 冒泡排序</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> a[] , <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-i<span class="number">-1</span>; j++) &#123; <span class="comment">// 比较两个相邻的元素</span></span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2，快速排序：</strong>选取一个基准元素(通常已需要排序的数组第一个数)，然后通过一趟排序将比基准数大的放在右边，比基准数小的放在左边，接着对划分好的两个数组再进行上述的排序。快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。<br>挖坑填数进行总结<br>1)．i = left;   j = right; 将基准数挖出形成第一个坑a[i]。<br>2)．j- -由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。<br>3)．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。<br>4)．再重复执行2，3二步，直到i==j，将基准数填入a[i]中。</p><figure class="highlight c"><figcaption><span>// 快速排序</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) &#123; <span class="comment">// 如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = right;</span><br><span class="line">    <span class="keyword">int</span> key = a[left];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123; <span class="comment">// 控制在当前组内寻找一遍</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; key &lt;= a[j]) &#123;</span><br><span class="line">            j--; <span class="comment">// 向前寻找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            a[i] = a[j]; <span class="comment">// 将比第一个小的移到低端</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; key &gt;= a[i]) &#123;</span><br><span class="line">            i++; <span class="comment">// 向后寻找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            a[j] = a[i]; <span class="comment">// 将比第一个大的移到高端</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[i] = key; <span class="comment">// 当在当组内找完一遍以后就把中间数key回归</span></span><br><span class="line">    </span><br><span class="line">    qsort(a, left, i - <span class="number">1</span>);</span><br><span class="line">    qsort(a, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p><strong>1，简单选择排序：</strong>面对一排数，假设第一个数是最小的，将第一个数依次与后面的所有数据进行比较，如发现更小的就把该数的下标记录下来，再将这个数与后面的数比较，一轮下来以后如果发现最小的数的下标不是第一个，就与第一个数交换，这样就保证了第一个位置上的数是最小的；对除去第一个数的剩下的数做同样的操作，多轮循环之后，直到剩下最后一个数，排序结束。</p><figure class="highlight c"><figcaption><span>// 简单选择排序</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simpleChoiceSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[m]) &#123; <span class="comment">// 如果第j个元素比第m个元素小，将j赋值给m</span></span><br><span class="line">                m = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i != m) &#123; <span class="comment">// 交换m和i两个元素的位置</span></span><br><span class="line">            <span class="keyword">int</span> t = a[i];</span><br><span class="line">            a[i] = a[m];</span><br><span class="line">            a[m] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2，堆排序（heap sort）：</strong>堆有两个性质，一是堆中某个节点的值总是不大于或不小于其父节点的值，二是堆是一棵完全树。以从大到小排序为例，首先要把得到的数组构建为一个最小堆，这样父节点均是小于或者等于子结点，根节点就是最小值，然后让根节点与尾节点交换，这样一次之后，再把前n－1个元素构建出最小根堆，让根结点与第n－2个元素交换，依此类推，得到降序序列。时间复杂度：O(nlgn)</p><figure class="highlight c"><figcaption><span>// 堆排序 从大到小排序</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 以i节点为根，调整为堆的算法，n是节点总数，i节点的子结点为i*2+1,i*2+2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapMin</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tmp保存根节点，j为左孩子编号</span></span><br><span class="line">    <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">    <span class="keyword">int</span> j = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j+<span class="number">1</span> &lt; n &amp;&amp; a[j+<span class="number">1</span>] &lt; a[j]) &#123; <span class="comment">// 在左右孩子中找最小的</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &gt;= tmp) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        i = j;</span><br><span class="line">        j = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapMax</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tmp保存根节点，j为左孩子编号</span></span><br><span class="line">    <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">    <span class="keyword">int</span> j = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; j &lt; n; j = j*<span class="number">2</span>+<span class="number">1</span>) &#123; <span class="comment">//从i结点的左子结点开始，也就是2i+1处开始</span></span><br><span class="line">        <span class="keyword">if</span> (j+<span class="number">1</span> &lt; n &amp;&amp; a[j] &lt; a[j+<span class="number">1</span>]) &#123; <span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &gt; tmp) &#123; <span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            i = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[i] = tmp; <span class="comment">//将tmp值放到最终的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// n/2-1最后一个非叶子节点</span></span><br><span class="line">    <span class="comment">// 下面这个操作是建立最小堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n/<span class="number">2</span><span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapMin(a, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for语句为输出堆顶元素，调整堆操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">        <span class="comment">// 堆顶与堆尾交换</span></span><br><span class="line">        <span class="keyword">int</span> tmp = a[<span class="number">0</span>];</span><br><span class="line">        a[<span class="number">0</span>] = a[j];</span><br><span class="line">        a[j] = tmp;</span><br><span class="line">        heapMin(a, <span class="number">0</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到的就是降序序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序（merge-sort）"><a href="#归并排序（merge-sort）" class="headerlink" title="归并排序（merge sort）"></a>归并排序（merge sort）</h3><p><strong>1，两路归并排序（Merge Sort）：</strong>也就是我们常说的归并排序，也叫合并排序。归并操作即将两个顺序序列合并成一个顺序序列的方法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。<br>最差时间复杂度：O(nlgn)<br>平均时间复杂度：O(nlgn)<br>最差空间复杂度：O(n)<br>稳定性：稳定</p><p>归并操作的基本步骤如下：<br>1.申请两个与已经排序序列相同大小的空间，并将两个序列拷贝其中；<br>2.设定最初位置分别为两个已经拷贝排序序列的起始位置，比较两个序列元素的大小，依次选择相对小的元素放到原始序列；<br>3.重复2直到某一拷贝序列全部放入原始序列，将另一个序列剩下的所有元素直接复制到原始序列尾。</p><p>设归并排序的当前区间是a[low..high]，分治法的三个步骤是：<br>1.分解：将当前区间一分为二，即求分裂点<br>2.求解：递归地对两个子区间a[low..mid]和a[mid+1..high]进行归并排序；<br>3.组合：将已排序的两个子区间a[low..mid]和a[mid+1..high]归并为一个有序的区间a[low..high]。<br>递归的终结条件：子区间长度为1（一个记录自然有序）。</p><figure class="highlight c"><figcaption><span>// 归并子算法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 将有序的a[low...mid]和a[mid+1...high]归并为有序的tmp[low...high]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> tmp[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = low;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i != mid + <span class="number">1</span> &amp;&amp; j != high + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt;= a[j]) &#123;</span><br><span class="line">            tmp[k++] = a[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[k++] = a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i != mid + <span class="number">1</span>) &#123;</span><br><span class="line">        tmp[k++] = a[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (j != high + <span class="number">1</span>) &#123;</span><br><span class="line">        tmp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = low; i &lt;= high; i++) &#123;</span><br><span class="line">        a[i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两路归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> tmp[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(a, tmp, low, mid);</span><br><span class="line">        mergeSort(a, tmp, mid + <span class="number">1</span>, high);</span><br><span class="line">        merge(a, tmp, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基数排序（radix-sort）"><a href="#基数排序（radix-sort）" class="headerlink" title="基数排序（radix sort）"></a>基数排序（radix sort）</h3><p>又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p><p>最高位优先(Most Significant Digit first)法，简称MSD法：先按k1排序分组，同一组中记录，关键码k1相等，再对各组按k2排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码kd对各子组排序后。再将各组连接起来，便得到一个有序序列。</p><p>最低位优先(Least Significant Digit first)法，简称LSD法：先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。 </p><p>LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。</p><p><a href="https://www.cnblogs.com/chengxiao/category/880910.html" target="_blank" rel="noopener">图解排序算法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;排序分为内部排序和外部排序，内部排序指待排序的记录在内存中，外部排序的记录数量很大，以至于内存放不下而放在外存中，排序过程需要访问外存。这里仅介绍内部排序，包括插入排序、交换排序、选择排序、归并排序、基数排序。&lt;/p&gt;
&lt;h3 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://blog.lzxy169.com/categories/Algorithm/"/>
    
    
      <category term="c" scheme="http://blog.lzxy169.com/tags/c/"/>
    
      <category term="c++" scheme="http://blog.lzxy169.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 命令</title>
    <link href="http://blog.lzxy169.com/2018/04/08/hexo-command/"/>
    <id>http://blog.lzxy169.com/2018/04/08/hexo-command/</id>
    <published>2018-04-08T06:10:08.000Z</published>
    <updated>2018-07-30T07:39:01.992Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;new article&quot;</span><br></pre></td></tr></table></figure><h3 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h3><p>草稿相当于很多博客都有的“私密文章”功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new draft &quot;new draft&quot;</span><br></pre></td></tr></table></figure></p><p>会在source/drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动drafts目录之中。</p><p>如果你希望强行预览草稿，更改配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ render_drafts: true</span><br></pre></td></tr></table></figure></p><p>或者，如下方式启动server：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server --drafts</span><br></pre></td></tr></table></figure></p><p>下面这条命令可以把草稿变成文章，或者页面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure></p><h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g #安装  </span><br><span class="line">npm update hexo -g #升级  </span><br><span class="line">hexo init #初始化</span><br></pre></td></tr></table></figure><h3 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章</span><br><span class="line">hexo p == hexo publish</span><br><span class="line">hexo g == hexo generate#生成</span><br><span class="line">hexo s == hexo server #启动服务预览</span><br><span class="line">hexo d == hexo deploy#部署</span><br></pre></td></tr></table></figure><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。</span><br><span class="line">hexo server -s #静态模式</span><br><span class="line">hexo server -p 5000 #更改端口</span><br><span class="line">hexo server -i 192.168.1.1 #自定义 IP</span><br><span class="line"></span><br><span class="line">hexo clean #清除缓存 网页正常情况下可以忽略此条命令</span><br><span class="line">hexo g #生成静态网页</span><br><span class="line">hexo d #开始部署</span><br></pre></td></tr></table></figure><h3 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate #使用 Hexo 生成静态文件快速而且简单</span><br><span class="line">hexo generate --watch #监视文件变动</span><br></pre></td></tr></table></figure><h3 id="完成后部署"><a href="#完成后部署" class="headerlink" title="完成后部署"></a>完成后部署</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">两个命令的作用是相同的</span><br><span class="line">hexo generate --deploy</span><br><span class="line">hexo deploy --generate</span><br><span class="line"></span><br><span class="line">hexo deploy -g</span><br><span class="line">hexo server -g</span><br></pre></td></tr></table></figure><h3 id="草稿-1"><a href="#草稿-1" class="headerlink" title="草稿"></a>草稿</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</span><br><span class="line">hexo deploy #将.deploy目录部署到GitHub</span><br><span class="line"></span><br><span class="line">hexo new [layout] &lt;title&gt;</span><br><span class="line">hexo new photo &quot;My Gallery&quot;</span><br><span class="line">hexo new &quot;Hello World&quot; --lang tw</span><br></pre></td></tr></table></figure><h3 id="模版（Scaffold）"><a href="#模版（Scaffold）" class="headerlink" title="模版（Scaffold）"></a>模版（Scaffold）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new photo &quot;My Gallery&quot;</span><br></pre></td></tr></table></figure><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &lt;title&gt;</span><br><span class="line">hexo new post &lt;title&gt;</span><br></pre></td></tr></table></figure><h3 id="推送到服务器上"><a href="#推送到服务器上" class="headerlink" title="推送到服务器上"></a>推送到服务器上</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo n #写文章</span><br><span class="line">hexo g #生成</span><br><span class="line">hexo d #部署 #可与hexo g合并为 hexo d -g</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;文章&quot;&gt;&lt;a href=&quot;#文章&quot; class=&quot;headerlink&quot; title=&quot;文章&quot;&gt;&lt;/a&gt;文章&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
      <category term="Hexo" scheme="http://blog.lzxy169.com/categories/Hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>简记Hexo及NexT主题的安装使用</title>
    <link href="http://blog.lzxy169.com/2018/04/08/hexo-next-startup/"/>
    <id>http://blog.lzxy169.com/2018/04/08/hexo-next-startup/</id>
    <published>2018-04-08T05:11:08.000Z</published>
    <updated>2018-04-19T03:03:42.910Z</updated>
    
    <content type="html"><![CDATA[<h4 id="官方文档："><a href="#官方文档：" class="headerlink" title="官方文档："></a>官方文档：</h4><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo中文文档</a><br><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">NexT中文文档</a><br><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">NexT源码</a></p><p>在Mac系统下搞了个博客，简单的记述一下从无到有的过程。<br>在官方文档里有详细的安装以及使用教程，不想看文档的话可以按照下面的步骤快速的搭建。</p><h4 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 <a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure><h4 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 <a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install git</span><br></pre></td></tr></table></figure><h4 id="安装-nvm"><a href="#安装-nvm" class="headerlink" title="安装 nvm"></a>安装 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a></h4><p>nvm: Node Version Manager，安装 Node.js 的最佳方式是使用 nvm。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br><span class="line">// 或者</span><br><span class="line">$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.9/install.sh | bash</span><br></pre></td></tr></table></figure></p><p>安装完成后，重启终端nvm环境才生效。</p><h4 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install stable</span><br></pre></td></tr></table></figure><h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>hexo 简单的命令格式，比如：<br>hexo g == hexo generate<br>hexo d == hexo deploy<br>hexo s == hexo server<br>hexo n == hexo new</p><h4 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo n <span class="string">"我的新博客"</span></span><br><span class="line">$ hexo g -d</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>浏览器输入：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 就可以看到了</p><p>Hexo目录：<br>_config.yml  博客的配置文件<br>scaffolds      博客文章模板<br>source          博客文章目录<br>themes        存放主题文件</p><blockquote><p><strong>Tip: </strong> hexo deploy出错解决方法：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h4 id="安装-NexT-主题"><a href="#安装-NexT-主题" class="headerlink" title="安装 NexT 主题"></a>安装 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">NexT</a> 主题</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p><strong>配置主题</strong><br>打开站点配置文件<strong>_config.yml</strong>，找到<strong>theme</strong>字段，并将其值更改为<strong>next</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure></p><p><strong>更改主题外观</strong><br>找到 …/themes/next/<strong>_config.yml</strong> 文件，更改 <strong>scheme</strong> 字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Schemes</span><br><span class="line"># scheme: Muse</span><br><span class="line">scheme: Mist</span><br><span class="line"># scheme: Pisces</span><br><span class="line"># scheme: Gemini</span><br></pre></td></tr></table></figure></p><p><strong>使主题生效：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g -d</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></p><p>到这里博客的本地搭建已经完成了，这只是开始。<br>如果想要博客让别人也能看见，那就得申请域名把博客部署到服务器，然后别人通过域名访问就可以浏览你的博客啦。<br>当然你可以把博客部署到<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>或者<a href="https://coding.net/" target="_blank" rel="noopener">Coding</a>又或者别的服务器等，域名购买有<a href="https://www.dnspod.cn/" target="_blank" rel="noopener">DNSPod</a>，<a href="https://wanwang.aliyun.com/" target="_blank" rel="noopener">万网</a>，<a href="https://sg.godaddy.com/" target="_blank" rel="noopener">GoDaddy</a>等等，有国内，国外自己考虑，之后还想要自己的博客有个性或者更好用那就选一个好看的主题DIY了。</p><p>至于写Markdown写作工具，各有所爱，我用的是<a href="https://www.sublimetext.com/" target="_blank" rel="noopener">Sublime Text</a>，装上 <a href="https://packagecontrol.io/" target="_blank" rel="noopener">Package Control</a>，<a href="https://packagecontrol.io/packages/MarkdownEditing" target="_blank" rel="noopener">Markdown​Editing</a>,  <a href="https://packagecontrol.io/packages/Markdown%20Preview" target="_blank" rel="noopener">Markdown Preview</a>或者<a href="https://packagecontrol.io/packages/Markdown%20Preview" target="_blank" rel="noopener">Omni​Markup​Previewer</a> 等插件，就可以愉快的玩耍了。</p><p>以下列出的条目可供参考，或许能帮上你～</p><h4 id="部署本地文件到github及源代码托管参考："><a href="#部署本地文件到github及源代码托管参考：" class="headerlink" title="部署本地文件到github及源代码托管参考："></a>部署本地文件到github及源代码托管参考：</h4><p><a href="http://www.aisun.org/2017/09/hexo+github+pages/index.html" target="_blank" rel="noopener">Hexo+GitHub Pages搭建的个人博客</a><br><a href="https://depthlove.github.io/2015/06/12/use-hexo-create-blog-in-mac/index.html" target="_blank" rel="noopener">Mac搭建hexo博客</a></p><h4 id="域名绑定参考-："><a href="#域名绑定参考-：" class="headerlink" title="域名绑定参考 ："></a>域名绑定参考 ：</h4><p><a href="http://blog.sunnyxx.com/2014/02/27/hexo_startup/" target="_blank" rel="noopener">hexo边搭边记</a><br><a href="https://blog.csdn.net/tyro_java/article/details/51348477" target="_blank" rel="noopener">在github上搭建自己的主页和顶级域名的绑定</a></p><h4 id="NexT主题定制参考："><a href="#NexT主题定制参考：" class="headerlink" title="NexT主题定制参考："></a>NexT主题定制参考：</h4><p><a href="http://www.aisun.org/2017/10/hexo-next+dingzhi/index.html" target="_blank" rel="noopener">hexo框架基于next主题定制</a><br><a href="https://blog.csdn.net/miaoqiucheng/article/details/72794165" target="_blank" rel="noopener">基于Hexo+Next主题的个人博客搭建定制优化</a><br><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">hexo的next主题个性化教程:打造炫酷网站</a> </p><h4 id="Markdown-语法参考-："><a href="#Markdown-语法参考-：" class="headerlink" title="Markdown 语法参考 ："></a>Markdown 语法参考 ：</h4><p><a href="https://www.jianshu.com/p/b03a8d7b1719" target="_blank" rel="noopener">Markdown 语法整理大集合2017</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;官方文档：&quot;&gt;&lt;a href=&quot;#官方文档：&quot; class=&quot;headerlink&quot; title=&quot;官方文档：&quot;&gt;&lt;/a&gt;官方文档：&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://hexo.io/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
      <category term="Hexo" scheme="http://blog.lzxy169.com/categories/Hexo/"/>
    
    
  </entry>
  
</feed>
