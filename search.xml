<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[APM Open sources]]></title>
    <url>%2F2018%2F07%2F02%2FAPM-Open-sources%2F</url>
    <content type="text"><![CDATA[1，PLCrashReporter， Home: Crash reporting for iOS and Mac OS X 2，KSCrash: The Ultimate iOS Crash Reporter 3，FBRetainCycleDetector: iOS library to help detecting retain cycles in runtime. 4，GYMonitor: base on PLCrashReporter: A collection of code for profiling iOS app, such as monitoring FPS. 5，MLeaksFinder: Find memory leaks in your iOS app at develop time. base on FBRetainCycleDetector 6，libextobjc: A Cocoa library to extend the Objective-C programming language.]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AFNetworking 解析]]></title>
    <url>%2F2018%2F06%2F02%2FAFNetworking-analysis%2F</url>
    <content type="text"><![CDATA[NSURLSessionNSURLSession 使用 NSURLRequest 来包含请求信息，来生成各种类型的 Task，使用 NSURLSessionConfiguration 来生成配置信息调用 - (void)resume 来发送请求， 生成 NSURLResponse 来返回请求的信息。回调的方式有delegate，和block两种形式。 12345678910@interface NSURLSessionDataTask : NSURLSessionTask@interface NSURLSessionUploadTask : NSURLSessionDataTask@interface NSURLSessionDownloadTask : NSURLSessionTask@interface NSURLSessionStreamTask : NSURLSessionTask@protocol NSURLSessionDelegate &lt;NSObject&gt;@protocol NSURLSessionTaskDelegate &lt;NSURLSessionDelegate&gt;@protocol NSURLSessionDataDelegate &lt;NSURLSessionTaskDelegate&gt;@protocol NSURLSessionDownloadDelegate &lt;NSURLSessionTaskDelegate&gt;@protocol NSURLSessionStreamDelegate &lt;NSURLSessionTaskDelegate&gt; AFNetworkingAFNetworking是封装的NSURLSession的网络请求。 AFNetworking核心由五个模块组成：SessionManager ：主要对象 NSURLSession 对象进行了进一步的封装Request/Response Serialization，提供了与请求数据和解析数据相关的操作接口SecurityPolicy，提供了与安全性相关的操作接口，主要是证书验证NetworkReachabilityManager，提供了与网络状态监听相关的操作接口以及的UIKit的一些类扩展，提供了大量网络请求过程中与UI界面显示相关的操作接口，通常用于网络请求过程中提示，使用户交互更加友好 SessionManager：123@interface AFURLSessionManager : NSObject &lt;NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate, NSSecureCoding, NSCopying&gt;@interface AFHTTPSessionManager : AFURLSessionManager &lt;NSSecureCoding, NSCopying&gt; HTTPMethod：1@&quot;GET&quot;，@&quot;HEAD&quot;，@&quot;POST&quot;，@&quot;PUT&quot;，@&quot;PATCH&quot;，@&quot;DELETE&quot; Request：1234@protocol AFURLRequestSerialization &lt;NSObject, NSSecureCoding, NSCopying&gt;@interface AFHTTPRequestSerializer : NSObject &lt;AFURLRequestSerialization&gt;@interface AFJSONRequestSerializer : AFHTTPRequestSerializer@interface AFPropertyListRequestSerializer : AFHTTPRequestSerializer Response：@protocol AFURLResponseSerialization &lt;NSObject, NSSecureCoding, NSCopying&gt;@interface AFHTTPResponseSerializer : NSObject @interface AFJSONResponseSerializer : AFHTTPResponseSerializer@interface AFXMLParserResponseSerializer : AFHTTPResponseSerializer@interface AFPropertyListResponseSerializer : AFHTTPResponseSerializer@interface AFImageResponseSerializer : AFHTTPResponseSerializer@interface AFCompoundResponseSerializer : AFHTTPResponseSerializer YTKNetworkYTKNetwork 由 Request， RequestAgent，NetworkConfig组成，对 AFNetworking 的封装 1234567891011121314151617YTKRequestMethod：YTKRequestMethodGET,YTKRequestMethodPOST,YTKRequestMethodHEAD,YTKRequestMethodPUT,YTKRequestMethodDELETE,YTKRequestMethodPATCH,Request：@protocol YTKRequestDelegate &lt;NSObject&gt;@interface YTKBaseRequest : NSObject@protocol YTKBatchRequestDelegate &lt;NSObject&gt;@interface YTKBatchRequest : NSObject@protocol YTKChainRequestDelegate &lt;NSObject&gt;@interface YTKChainRequest : NSObject]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ARC(Automatic Reference Counting)简记]]></title>
    <url>%2F2018%2F04%2F16%2Farc-record%2F</url>
    <content type="text"><![CDATA[ARC概述 在Objective-C中采用Automatic Reference Counting(ARC)机制，让编译器(clang)和运行时库协助(objc4)来进行内存管理。 内存管理的思考方式 自己生成的对象，自己持有 非自己生成的对象，自己也能持有 不再需要自己持有的对象时释放 非自己持有的对象无法释放 对象操作与Objective-C方法的对应： 对象操作 Objective-C方法 生成并持有对象 alloc/new/copy/mutableCopy 等方法 持有对象 retain方法 释放对象 release方法 废弃对象 dealloc方法 “自己”：对象的使用环境 苹果采用散列表(引用计数表)来管理引用计数 123456789101112131415161718192021222324252627282930313233343536static struct &#123; CFLock_t lock; CFBasicHashRef table;// uint8_t padding[64 - sizeof(CFBasicHashRef) - sizeof(CFLock_t)];&#125; __NSRetainCounters[NUM_EXTERN_TABLES];CF_EXPORT uintptr_t __CFDoExternRefOperation(uintptr_t op, id obj) &#123; if (nil == obj) HALT; uintptr_t idx = EXTERN_TABLE_IDX(obj); uintptr_t disguised = DISGUISE(obj); CFLock_t *lock = &amp;__NSRetainCounters[idx].lock; CFBasicHashRef table = __NSRetainCounters[idx].table; // 取得对象对应的散列表 uintptr_t count; switch (op) &#123; case 300: // increment case 350: // increment, no event __CFLock(lock); CFBasicHashAddValue(table, disguised, disguised); __CFUnlock(lock); if (__CFOASafe &amp;&amp; op != 350) __CFRecordAllocationEvent(__kCFObjectRetainedEvent, obj, 0, 0, NULL); return (uintptr_t)obj; case 400: // decrement if (__CFOASafe) __CFRecordAllocationEvent(__kCFObjectReleasedEvent, obj, 0, 0, NULL); case 450: // decrement, no event __CFLock(lock); count = (uintptr_t)CFBasicHashRemoveValue(table, disguised); __CFUnlock(lock); return 0 == count; case 500: __CFLock(lock); count = (uintptr_t)CFBasicHashGetCountOfKey(table, disguised); __CFUnlock(lock); return count; &#125; return 0;&#125; CF-1153.18/CFRuntime.c CFBasicHashRef 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172CF_PRIVATE CFBasicHashRef CFBasicHashCreate(CFAllocatorRef allocator, CFOptionFlags flags, const CFBasicHashCallbacks *cb) &#123; size_t size = sizeof(struct __CFBasicHash) - sizeof(CFRuntimeBase); if (flags &amp; kCFBasicHashHasKeys) size += sizeof(CFBasicHashValue *); // keys if (flags &amp; kCFBasicHashHasCounts) size += sizeof(void *); // counts if (flags &amp; kCFBasicHashHasHashCache) size += sizeof(uintptr_t *); // hashes CFBasicHashRef ht = (CFBasicHashRef)_CFRuntimeCreateInstance(allocator, CFBasicHashGetTypeID(), size, NULL); if (NULL == ht) return NULL; ht-&gt;bits.finalized = 0; ht-&gt;bits.hash_style = (flags &gt;&gt; 13) &amp; 0x3; ht-&gt;bits.fast_grow = (flags &amp; kCFBasicHashAggressiveGrowth) ? 1 : 0; ht-&gt;bits.counts_width = 0; ht-&gt;bits.strong_values = (flags &amp; kCFBasicHashStrongValues) ? 1 : 0; ht-&gt;bits.strong_keys = (flags &amp; kCFBasicHashStrongKeys) ? 1 : 0; ht-&gt;bits.weak_values = (flags &amp; kCFBasicHashWeakValues) ? 1 : 0; ht-&gt;bits.weak_keys = (flags &amp; kCFBasicHashWeakKeys) ? 1 : 0; ht-&gt;bits.int_values = (flags &amp; kCFBasicHashIntegerValues) ? 1 : 0; ht-&gt;bits.int_keys = (flags &amp; kCFBasicHashIntegerKeys) ? 1 : 0; ht-&gt;bits.indirect_keys = (flags &amp; kCFBasicHashIndirectKeys) ? 1 : 0; ht-&gt;bits.num_buckets_idx = 0; ht-&gt;bits.used_buckets = 0; ht-&gt;bits.deleted = 0; ht-&gt;bits.mutations = 1; if (ht-&gt;bits.strong_values &amp;&amp; ht-&gt;bits.weak_values) HALT; if (ht-&gt;bits.strong_values &amp;&amp; ht-&gt;bits.int_values) HALT; if (ht-&gt;bits.strong_keys &amp;&amp; ht-&gt;bits.weak_keys) HALT; if (ht-&gt;bits.strong_keys &amp;&amp; ht-&gt;bits.int_keys) HALT; if (ht-&gt;bits.weak_values &amp;&amp; ht-&gt;bits.int_values) HALT; if (ht-&gt;bits.weak_keys &amp;&amp; ht-&gt;bits.int_keys) HALT; if (ht-&gt;bits.indirect_keys &amp;&amp; ht-&gt;bits.strong_keys) HALT; if (ht-&gt;bits.indirect_keys &amp;&amp; ht-&gt;bits.weak_keys) HALT; if (ht-&gt;bits.indirect_keys &amp;&amp; ht-&gt;bits.int_keys) HALT; uint64_t offset = 1; ht-&gt;bits.keys_offset = (flags &amp; kCFBasicHashHasKeys) ? offset++ : 0; ht-&gt;bits.counts_offset = (flags &amp; kCFBasicHashHasCounts) ? offset++ : 0; ht-&gt;bits.hashes_offset = (flags &amp; kCFBasicHashHasHashCache) ? offset++ : 0;#if DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI ht-&gt;bits.hashes_offset = 0; ht-&gt;bits.strong_values = 0; ht-&gt;bits.strong_keys = 0; ht-&gt;bits.weak_values = 0; ht-&gt;bits.weak_keys = 0;#endif ht-&gt;bits.__kret = CFBasicHashGetPtrIndex((void *)cb-&gt;retainKey); ht-&gt;bits.__vret = CFBasicHashGetPtrIndex((void *)cb-&gt;retainValue); ht-&gt;bits.__krel = CFBasicHashGetPtrIndex((void *)cb-&gt;releaseKey); ht-&gt;bits.__vrel = CFBasicHashGetPtrIndex((void *)cb-&gt;releaseValue); ht-&gt;bits.__kdes = CFBasicHashGetPtrIndex((void *)cb-&gt;copyKeyDescription); ht-&gt;bits.__vdes = CFBasicHashGetPtrIndex((void *)cb-&gt;copyValueDescription); ht-&gt;bits.__kequ = CFBasicHashGetPtrIndex((void *)cb-&gt;equateKeys); ht-&gt;bits.__vequ = CFBasicHashGetPtrIndex((void *)cb-&gt;equateValues); ht-&gt;bits.__khas = CFBasicHashGetPtrIndex((void *)cb-&gt;hashKey); ht-&gt;bits.__kget = CFBasicHashGetPtrIndex((void *)cb-&gt;getIndirectKey); for (CFIndex idx = 0; idx &lt; offset; idx++) &#123; ht-&gt;pointers[idx] = NULL; &#125;#if ENABLE_MEMORY_COUNTERS int64_t size_now = OSAtomicAdd64Barrier((int64_t) CFBasicHashGetSize(ht, true), &amp; __CFBasicHashTotalSize); while (__CFBasicHashPeakSize &lt; size_now &amp;&amp; !OSAtomicCompareAndSwap64Barrier(__CFBasicHashPeakSize, size_now, &amp; __CFBasicHashPeakSize)); int64_t count_now = OSAtomicAdd64Barrier(1, &amp; __CFBasicHashTotalCount); while (__CFBasicHashPeakCount &lt; count_now &amp;&amp; !OSAtomicCompareAndSwap64Barrier(__CFBasicHashPeakCount, count_now, &amp; __CFBasicHashPeakCount)); OSAtomicAdd32Barrier(1, &amp;__CFBasicHashSizes[ht-&gt;bits.num_buckets_idx]);#endif return ht;&#125; CF-1153.18/CFBasicHash.c 所有权修饰符 Objective-C 中为了处理对象，将类型定义为 id 类型或各种对象类型 id 类型用于隐藏类型的类名，相当于C语言中的 void *。 __strong： 表示对对象的“强引用”。持有强引用的变量，在超出其作用域时强引用失效，所以自动地释放自己持有的对象，对象的所有者不存在，因此废弃该对象。该修饰符是 id 类型和对象类型默认的所有权修饰符。 __weak： 表示对对象的“弱引用”。持有弱引用的变量，在超出其作用域时，对象即被释放。在持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效且被赋值为 nil (空弱引用)。 __unsafe_unretained： 附有该修饰符的变量不属于编译器的内存管理对象。既不持有对象的强引用也不持有对象的弱引用，只是表示对象，若该对象被废弃，其为悬垂指针。 __autoreleasing： 属性声明的属性与所有权修饰符的对应关系 属性声明的属性 所有权修饰符 assign __unsafe_unretained copy __strong (赋值的是被复制的对象) retain __strong strong __strong weak __weak unsafe_unretained __unsafe_unretained 内存泄漏就是应当废弃的对象在超出其生存周期后继续存在。相互引用(循环引用)容易发生内存泄漏。 野指针是指向“垃圾”内存（不可用内存）的指针。不是NULL指针。 悬垂指针是指指向曾经存在的对象，但该对象已经不再存在了。 附有 __strong 和 __weak 修饰符的变量类似于C++中的智能指针 std::shared_ptr 和 std::weak_ptr。std::shared_ptr 可通过引用计数来持有C++ 类实例，std::weak_ptr 可避免循环引用。 autorelease 类似于C语言中的自动变量(局部变量)的特性。若某自动变量超出其作用域，改自动变量将被自动废弃。 autorelease 的具体用法： 生成并持有 NSAutoreleasePool 对象 调用已分配对象的 autorelease 实例方法 废弃 NSAutoreleasePool 对象1234567891011121314151617181920/* ARC无效 */NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];// 等同于 objc_autoreleasePoolPush();id obj = [[NSObject alloc] init];[obj autorelease];// 等同于 objc_autorelease(obj);[pool drain];// 等同于 objc_autoreleasePoolPop(pool);/* ARC有效 */@autoreleasepool &#123; // 显式 id __autoreleasing obj = [[NSObject alloc] init];&#125;@autoreleasepool &#123; // 非显式 // 非自己生成并持有的对象 id __strong obj = [NSMutableArray array];&#125; ARC有效时，指定“@autoreleasepool 块”来代替“NSAutoreleasePool 类对象生成，持有以及废弃”。通过将对象赋值给附加了__autoreleasing 修饰符的变量来代替调用 autorelease 方法。对象赋值给附有 __autoreleasing 修饰符的变量等价于在ARC无效时调用对象的 autorelease 方法，即对象被注册到 autoreleasepool 。 非显式地使用 __autoreleasing 也可以。这是由于编译器会检查方法名是否以 alloc/new/copy/mutableCopy 开始，如果不是则自动将返回的对象注册到 autoreleasepool 。 1234+ (id)array &#123; id obj = [[NSMutableArray alloc] init]; return obj;&#125; 以上为取得非自己生成并持有的对象时被调用方法的源代码示例。因为没有显式指定所有权修饰符所以 id obj 同附有 __strong 修饰符的 id __strong obj 是完全一样的。由于 return 使得对象变量超出其作用域，所以该强引用对应的自己持有的对象会被自动释放，但该对象作为函数的返回值，编译器会自动将其注册到 autoreleasepool 中。 id 的指针(id *obj)或对象的指针(NSObject **obj)在没有显式指定时会被附加上 __autoreleasing 修饰符。使用附有 __autoreleasing 修饰符的变量作为对象取得参数，都会注册到 autoreleasepool ， 并取得非自己生成并持有的对象。 如下：123456789101112131415- (BOOL)performOperationWithError:(NSError * __autoreleasing *)error &#123; *error = [[NSError alloc] initWithDomain:@&quot;Domain&quot; code:0 userInfo:nil]; return NO;&#125;// 调用方法NSError __strong *error = nil;BOOL result = [obj performOperationWithError: &amp;error];编译器转化上述代码为下：NSError __strong *error = nil;NSError __autoreleasing *tmp = error;BOOL result = [obj performOperationWithError: &amp;tmp];error = tmp; 在显式地指定 __autoreleasing 修饰符时，必须注意对象变量要为自动变量(包括局部变量，函数，以及方法参数)。 在访问附有 __weak 修饰符的变量时，实际上必定要访问注册到 autoreleasepool 的对象。为什么？12345678id __strong obj0 = [[NSObject alloc] init];id __weak obj1 = obj0;NSLog(@&quot;class = %@&quot;, [obj1 class]);编译器转化上述代码为下：id __weak obj1 = obj0;id __autoreleasing tmp = obj1;NSLog(@&quot;class = %@&quot;, [tmp class]); 这是因为 __weak 修饰符只持有对象的弱引用，而在访问引用对象的过程中，该对象有可能被废弃。如果把要访问的对象注册到 autoreleasepool 中，那么在 @autoreleasepool 块结束之前都能确保该对象存在。 在Cocoa框架中，相当于主循环的 NSRunLoop 或者在其他程序可运行的地方，对 NSAutoreleasePool 对象进行生成，持有和废弃处理。 Cocoa框架中有很多类方法用于返回 autorelease 的对象。比如：12id array = [NSMutableArray arrayWithCapacity:1];id array2 = [[[NSMutableArray alloc] initWithCapacity:1] autorelease]; 无论ARC是否有效，调试用的非公开函数 __objc__autoreleasePoolPrint() 都可使用。利用这一函数可调试注册到 autoreleasepool 上的对象。 autorelease 的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102class AutoreleasePoolPage &#123; id *add(id obj) &#123; id *ret = next; // faster than `return next-1` because of aliasing *next++ = obj; return ret; &#125; void releaseAll() &#123; releaseUntil(begin()); &#125; static inline id autorelease(id obj) &#123; assert(obj); assert(!obj-&gt;isTaggedPointer()); id *dest __unused = autoreleaseFast(obj); assert(!dest || dest == EMPTY_POOL_PLACEHOLDER || *dest == obj); return obj; &#125; static inline void *push() &#123; id *dest; if (DebugPoolAllocation) &#123; // Each autorelease pool starts on a new pool page. dest = autoreleaseNewPage(POOL_BOUNDARY); &#125; else &#123; dest = autoreleaseFast(POOL_BOUNDARY); &#125; assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY); return dest; &#125; static inline void pop(void *token) &#123; AutoreleasePoolPage *page; id *stop; if (token == (void*)EMPTY_POOL_PLACEHOLDER) &#123; // Popping the top-level placeholder pool. if (hotPage()) &#123; // Pool was used. Pop its contents normally. // Pool pages remain allocated for re-use as usual. pop(coldPage()-&gt;begin()); &#125; else &#123; // Pool was never used. Clear the placeholder. setHotPage(nil); &#125; return; &#125; page = pageForPointer(token); stop = (id *)token; if (*stop != POOL_BOUNDARY) &#123; if (stop == page-&gt;begin() &amp;&amp; !page-&gt;parent) &#123; // Start of coldest page may correctly not be POOL_BOUNDARY: // 1. top-level pool is popped, leaving the cold page in place // 2. an object is autoreleased with no pool &#125; else &#123; // Error. For bincompat purposes this is not // fatal in executables built with old SDKs. return badPop(token); &#125; &#125; if (PrintPoolHiwat) printHiwat(); page-&gt;releaseUntil(stop); // memory: delete empty children if (DebugPoolAllocation &amp;&amp; page-&gt;empty()) &#123; // special case: delete everything during page-per-pool debugging AutoreleasePoolPage *parent = page-&gt;parent; page-&gt;kill(); setHotPage(parent); &#125; else if (DebugMissingPools &amp;&amp; page-&gt;empty() &amp;&amp; !page-&gt;parent) &#123; // special case: delete everything for pop(top) // when debugging missing autorelease pools page-&gt;kill(); setHotPage(nil); &#125; else if (page-&gt;child) &#123; // hysteresis: keep one empty child if page is more than half full if (page-&gt;lessThanHalfFull()) &#123; page-&gt;child-&gt;kill(); &#125; else if (page-&gt;child-&gt;child) &#123; page-&gt;child-&gt;child-&gt;kill(); &#125; &#125; &#125; static void init() &#123; int r __unused = pthread_key_init_np(AutoreleasePoolPage::key, AutoreleasePoolPage::tls_dealloc); assert(r == 0); &#125;&#125; objc4-706/runtime/NSObject.mm ARC规则 不能使用 retain/release/retainCount/autorelease。在ARC下，内存管理是编译器的工作。 不能使用 NSAllocateObject/NSDeallocateObject 须遵守内存管理的方法命名规则。alloc/new/copy/mutableCopy，以这些名称开始的方法在返回对象时，必须返回给调用方所应当持有的对象。以 init 开始的方法必须是实例方法，并且必须要返回对象。返回的对象应为 id 类型或该方法声明类的对象类型，抑或是该类的超类或子类型。该返回对象不注册到 autoreleasepool 中。 基本上只是对 alloc 方法返回值的对象进行初始化处理并返回该对象。 不要显式调用 dealloc。 无论 ARC 是否有效，只要对象的所有者都不持有该对象，该对象就被废弃。对象被废弃时，不管 ARC 是否有效，都会调用对象的 dealloc 方法。 使用@autoreleasepool 块代替 NSAutoreleasePool 不能使用区域(NSZone) 对象型变量不能作为C语言结构体(struct/union)的成员。C语言的规范上没有方法来管理结构体成员的生存周期。要把对象型变量加入到结构体成员中时，可强制转换为 void *，或者时附加 __unsafe_unretained 。 附有该修饰符的变量不属于编译器的内存管理对象。 显式转换“ id ”和“ void * ”。 __bridge 转换 单纯的赋值转换。注意转换为 void * 的 __bridge 转换其安全性与赋值给 __unsafe_unretained 修饰符相近，甚至会更低。如果不注意赋值对象的所有者，就会因悬垂指针而导致程序崩溃。123id obj = [[NSObject alloc] init];void *p = (__bridge void *)obj;id o = (__bridge id)p; __bridge_retained 转换 可使要转换赋值的变量也持有所赋值的对象。12id obj = [[NSObject alloc] init];void *p = (__bridge_retained void *)obj; __bridge_transfer 转换 被转换的变量所持有的对象在该变量被赋值给转换目标变量后随之释放。1234id obj = [[NSObject alloc] init];void *p = (__bridge_retained void *)obj;id obj1 = (__bridge_transfer id)p; 以下函数可用于 Objective-C 对象与 Core Foundation 对象之间的相互变换，即 Toll-Free-Bridge 转化。由于这种转换不需要使用额外的CPU资源，因此也被称为“免费桥”。1234567CFTypeRef CFBridgingRetain(id _Nullable X) &#123; return (__bridge_retained CFTypeRef)X;&#125;id CFBridgingRelease(CFTypeRef _Nullable X) &#123; return (__bridge_transfer id)X;&#125; 使用方法：1234567NSMutableArray *obj = [[NSMutableArray alloc] initWithCapacity:1];CFMutableArrayRef cfobject = CFBridgingRetain(obj);CFShow(cfobject);CFRelease(cfobject);CFMutableArrayRef cfobject = CFArrayCreateMutable(kCFAllocatorDefault, 0, NULL);id obj = CFBridgingRelease(cfobject); ARC实现 __strong：表示对对象的“强引用”。引用计数为1。持有强引用的变量，在超出其作用域时强引用失效，所以自动地释放自己持有的对象，对象的所有者不存在，因此废弃该对象。该修饰符是 id 类型和对象类型默认的所有权修饰符。 123456id __strong obj = [[NSObject alloc] init];// 编译器的模拟代码：id obj = objc_msgSend(NSObject, @selector(alloc));objc_msgSend(obj, @selector(init));objc_release(obj); 使用 alloc/new/copy/mutableCopy 以外的方法 123456789101112131415+ (id)array &#123; return [[NSMutableArray alloc] init];&#125;// NSMutableArray 类的 array 类方法 通过编译器转换后的模拟代码：+ (id)array &#123; id obj = objc_msgSend(NSMutableArray, @selector(alloc)); objc_msgSend(obj, @selector(init)); return objc_autoreleaseReturnValue(obj);&#125;id __strong obj = [NSMutableArray array];// 编译器的模拟代码：id obj = objc_msgSend(NSMutableArray, @selector(array));objc_retainAutoreleasedReturnValue(obj)objc_release(obj); objc_autoreleaseReturnValue() 函数会检查使用该函数的方法或者函数调用方的执行命令列表，如果方法或者函数的调用方调用了方法或者函数后紧接着调用 objc_retainAutoreleasedReturnValue() 函数，那么就不将返回的对象注册到 autoreleasepool 中，而是直接传递到方法或者函数的调用方。而返回的对象则存储在 TLS 中， Thread Local Storage（TLS）线程局部存储，目的很简单，将一块内存作为某个线程专有的存储，以 key-value 的形式进行读写。在返回的对象身上调用 objc_autoreleaseReturnValue() 方法时， runtime 将这个返回的对象 obj 储存在 TLS 中，然后直接返回这个 obj （不调用autorelease）；同时，在外部接收这个返回的对象的方法 objc_retainAutoreleasedReturnValue() 里发现 TLS 中正好存了这个对象，那么直接返回这个 obj （不调用retain）。于是乎，调用方和被调方利用 TLS 做中转，很有默契的免去了对返回值的内存管理。这就是在ARC下，runtime 对 autorelease 返回值的优化策略。 Thread-local storage（线程局部存储）指向 hot page ，即最新添加的 autoreleased 对象所在的那个 page 。??? __weak： 表示对对象的“弱引用”。弱引用并不持有对象，不会改变赋值给附有 __weak 修饰符的变量的引用计数。持有弱引用的变量，在超出其作用域时，对象即被释放。在持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效且被赋值为 nil (空弱引用)。使用 __weak 修饰符的变量，即是使用注册到 autoreleasepool 中的对象，该对象的引用计数会加1。 1234567891011121314151617181920id __strong obj = [[NSObject alloc] init];id __weak obj1 = obj;NSLog(@&quot;%@&quot;, obj1);// 编译器的模拟代码：id obj1;objc_initWeak(&amp;obj1, obj);id tmp = objc_loadWeakRetained(&amp;obj1);objc_autorelease(tmp);NSLog(@&quot;%@&quot;, tmp);objc_destroyWeak(&amp;obj1);id objc_initWeak(id *location, id newObj) &#123; return storeWeak(location, (objc_object*)newObj);&#125;void objc_destroyWeak(id *location) &#123; (void)storeWeak(location, nil);&#125; storeWeak() 函数把第二参数的赋值对象的地址作为键值key，将第一参数的附有 __weak 修饰符的变量的地址作为键值 value 注册到 __weak 表中。如果第二参数(key)为 nil， 则把变量的地址(value)从 weak 表中删除。 weak 表与引用计数表相同，作为散列表被实现。如果使用 weak 表，将废弃对象的地址作为键值key进行检索，就能高速地获取对应的附有 __weak 修饰符的变量的地址。另外，由于一个对象可同时赋值给多个附有 __weak 修饰符的变量中，所以对于一个键值key，可注册多个变量的地址。 objc_loadWeakRetained() 函数取出附有 __weak 修饰符变量所引用的对象并 retain。objc_autorelease() 函数将对象注册到 autoreleasepool 中 。如果大量使用附有 __weak修饰符的变量，注册到 autoreleasepool 中的对象也会大量的增加，因此在使用附有 __weak修饰符的变量时，最好先暂时赋值给附有 __strong 修饰符的变量后使用。 对象废弃执行的动作 objc_release 当引用计数为0执行dealloc _objc_rootDealloc object_dispose objc_destructInstance objc_clear_deallocating 对象被弃用时最后调用objc_clear_deallocating 函数执行的动作 从 weak 表中获取废弃对象的地址为键值key的记录 将包含在记录中的所有附有 __weak 修饰符变量的地址，赋值为 nil 从weak 表中删除该记录 从引用计数表中删除废弃对象的地址为键值的记录 如果大量使用附有 __weak 修饰符的变量，则会消耗相应的CPU资源，良策是只在需要避免循环引用时使用 __weak 修饰符。 __unsafe_unretained： 附有该修饰符的变量不属于编译器的内存管理对象。既不持有对象的强引用也不持有对象的弱引用，只是表示对象，若该对象被废弃，其为悬垂指针。 __autoreleasing： 将对象赋值给有 __autoreleasing 修饰符的变量，等同于 ARC 无效时调用对象 autorelease 方法，会将对象注册到 autoreleasepool 中，对象的引用计数加1。 12345678910111213141516171819@autoreleasepool &#123; id __autoreleasing obj = [[NSObject alloc] init];&#125;/* 编译器的模拟代码 */id pool = objc_autoreleasePoolPush();id obj = objc_msgSend(NSObject, @selector(alloc));objc_msgSend(obj, @selector(init));objc_autorelease(obj);objc_autoreleasePoolPop(pool);@autoreleasepool &#123; id __autoreleasing obj = [NSMutableArray array];&#125;// 编译器的模拟代码：id pool = objc_autoreleasePoolPush();id obj = objc_msgSend(NSMutableArray, @selector(array));objc_retainAutoreleasedReturnValue(obj);objc_autorelease(obj);objc_autoreleasePoolPop(pool);]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++内存管理]]></title>
    <url>%2F2018%2F04%2F13%2Fc%3Ac%2B%2B-memory-management%2F</url>
    <content type="text"><![CDATA[内存分配 在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。 栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 堆：就是那些由new分配的内存块，它们的释放编译器不去管，由应用程序去控制，一般一个new就要对应一个delete。如果没有手动释放掉，那么在程序结束后，操作系统会自动回收。 自由存储区：就是那些由malloc等分配的内存块，它和堆是十分相似的，不过它是用free来结束自己的生命的。 全局静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。 常量存储区：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。 明确区分堆与栈 举个例子：1234void foo() &#123; int* p = new int[5]; delete []p;&#125; 这条短短的一句话就包含了堆与栈，看到new，我们首先就应该想到，我们分配了一块堆内存，那么指针p呢？他分配的是一块栈内存。 所以这行代码的意思就是：在栈内存中存放了一个指向一块堆内存的指针p。在程序会先确定在堆中分配内存的大小，然后调用operator new分配内存，然后返回这块内存的首地址，放入栈中。delete []p，这是为了告诉编译器：我删除的是一个数组，编译器就会根据相应的Cookie信息去进行释放内存的工作。 堆和栈的区别 管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。 空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，一般系统默认设置栈段为8M、4M、2M或1M。 碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。 生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。 分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloc函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。 分配效率：栈是系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。 从这里我们可以看到，堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。 虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。 无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果,就算是在你的程序运行过程中，没有发生上面的问题，你还是要小心，说不定什么时候就崩掉，那时候debug可是相当困难的：） 控制C++的内存分配 在嵌入式系统中使用C++的一个常见问题是内存分配，即对new 和 delete 操作符的失控。 具有讽刺意味的是，问题的根源却是C++对内存的管理非常的容易而且安全。具体地说，当一个对象被消除时，它的析构函数能够安全的释放所分配的内存。 这当然是个好事情，但是这种使用的简单性使得程序员们过度使用new 和 delete，而不注意在嵌入式C++环境中的因果关系。并且，在嵌入式系统中，由于内存的限制，频繁的动态分配不定大小的内存会引起很大的问题以及堆破碎的风险。 作为忠告，保守的使用内存分配是嵌入式环境中的第一原则。 但当你必须要使用new和delete时，你不得不控制C++中的内存分配。你需要用一个全局的new 和delete来代替系统的内存分配符，并且一个类一个类的重载new和delete。 一个防止堆破碎的通用方法是从不同固定大小的内存池中分配不同类型的对象。对每个类重载new 和delete就提供了这样的控制。 重载全局的new和delete操作符 可以很容易地重载new 和 delete 操作符，如下所示:1234567void *operator new(size_t size) &#123; void *p = malloc(size); return (p);&#125;void operator delete(void *p) &#123; free(p);&#125; 这段代码可以代替默认的操作符来满足内存分配的请求。出于解释C++的目的，我们也可以直接调用malloc() 和free()。 也可以对单个类的new 和 delete操作符重载。这是你能灵活的控制对象的内存分配。12345678910111213class TestClass &#123; public: void *operator new(size_t size); void operator delete(void *p); // .. other members here ...&#125;;void *TestClass::operator new(size_t size)&#123; void *p = malloc(size); // Replace this with alternative allocator return (p);&#125;void TestClass::operator delete(void *p)&#123; free(p); // Replace this with alternative de-allocator&#125; 所有TestClass 对象的内存分配都采用这段代码。更进一步，任何从TestClass 继承的类也都采用这一方式，除非它自己也重载了new 和 delete 操作符。通过重载new 和 delete 操作符的方法，你可以自由地采用不同的分配策略，从不同的内存池中分配不同的类对象。 为单个的类重载new[]和delete[] 必须小心对象数组的分配。你可能希望调用到被你重载过的new 和 delete 操作符，但并不如此。内存的请求被定向到全局的new[]和delete[] 操作符，而这些内存来自于系统堆。 C++将对象数组的内存分配作为一个单独的操作，而不同于单个对象的内存分配。为了改变这种方式，你同样需要重载new[] 和 delete[]操作符。123456789101112131415161718class TestClass &#123; public: void *operator new[ ](size_t size); void operator delete[ ](void *p); // .. other members here ..&#125;;void *TestClass::operator new[ ](size_t size)&#123; void *p = malloc(size); return (p);&#125;void TestClass::operator delete[ ](void *p)&#123; free(p);&#125;int main(void)&#123; TestClass *p = new TestClass[10]; // ... etc ... delete[ ] p;&#125; 但是注意：对于多数C++的实现，new[]操作符中的个数参数是数组的大小加上额外的存储对象数目的一些字节。在你的内存分配机制重要考虑的这一点。你应该尽量避免分配对象数组，从而使你的内存分配策略简单。 常见的内存错误及其对策 发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行时才能捕捉到。而这些错误大多没有明显的症状，时隐时现，增加了改错的难度。 常见的内存错误及其对策如下： 内存分配未成功，却使用了它。编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。 内存分配虽然成功，但是尚未初始化就引用它。犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。 内存分配成功并且已经初始化，但操作越过了内存的边界。例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。 忘记了释放内存，造成内存泄露。含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。 释放了内存却继续使用它。 有三种情况：(1). 程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。(2). 函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。(3). 使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。 那么如何避免产生野指针呢？这里列出了5条规则，平常写程序时多注意一下，养成良好的习惯。 规则1：用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。 规则2：不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。 规则3：避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。 规则4：动态内存的申请与释放必须配对，防止内存泄漏。 规则5：用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。 指针与数组的对比 C++/C程序中，指针和数组在不少地方可以相互替换着用，让人产生一种错觉，以为两者是等价的。 数组：要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（而不是指向）一块内存，其地址与容量在生命期内保持不变，只有数组的内容可以改变。 指针：可以随时指向任意类型的内存块，它的特征是“可变”，所以我们常用指针来操作动态内存。指针远比数组灵活，但也更危险。 下面以字符串为例比较指针与数组的特性。 修改内容 下面示例中，字符数组a的容量是6个字符，其内容为 hello。a的内容可以改变，如a[0]= ‘X’。指针p指向常量字符串“world”（位于静态存储区，内容为world），常量字符串的内容是不可以被修改的。从语法上看，编译器并不觉得语句p[0]= ‘X’有什么不妥，但是该语句企图修改常量字符串的内容而导致运行错误。 123456char a[] = “hello”;a[0] = ‘X’;cout &lt;&lt; a &lt;&lt; endl;char *p = “world”; // 注意p指向常量字符串p[0] = ‘X’; // 编译器不能发现该错误cout &lt;&lt; p &lt;&lt; endl; 内容复制与比较 不能对数组名进行直接复制与比较。若想把数组a的内容复制给数组b，不能用语句 b = a ，否则将产生编译错误。应该用标准库函数strcpy进行复制。同理，比较b和a的内容是否相同，不能用if(b==a) 来判断，应该用标准库函数strcmp进行比较。 语句 p = a 并不能把a的内容复制给指针p，而是把a的地址赋给了p。要想复制a的内容，可以先用库函数malloc为p申请一块容量为strlen(a)+1个字符的内存，再用strcpy进行字符串复制。同理，语句if(p==a) 比较的不是内容而是地址，应该用库函数strcmp来比较。 123456789101112// 数组…char a[] = "hello";char b[10];strcpy(b, a); // 不能用 b = a;if(strcmp(b, a) == 0) // 不能用 if (b == a)…// 指针…int len = strlen(a);char *p = (char *)malloc(sizeof(char)*(len+1));strcpy(p,a); // 不要用 p = a;if(strcmp(p, a) == 0) // 不要用 if (p == a)… 计算内存容量 用运算符sizeof可以计算出数组的容量（字节数）。如下示例中，sizeof(a)的值是12。指针p指向a，但是sizeof(p)的值却是4。这是因为sizeof(p)得到的是一个指针变量的字节数，相当于sizeof(char*)，而不是p所指的内存容量。C++/C语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。 1234char a[] = "hello world";char *p = a;cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12字节cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4字节 注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。如下示例中，不论数组a的容量是多少，sizeof(a)始终等于sizeof(char *)。123void Func(char a[100])&#123; cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4字节而不是100字节&#125; 指针参数是如何传递内存的 如果函数的参数是一个指针，不要指望用该指针去申请动态内存。如下示例中，Test函数的语句GetMemory(str, 200)并没有使str获得期望的内存，str依旧是NULL，为什么？12345678void GetMemory(char *p, int num)&#123; p = (char *)malloc(sizeof(char) * num);&#125;void Test(void)&#123; char *str = NULL; GetMemory(str, 100); // str 仍然为 NULL strcpy(str, "hello"); // 运行错误&#125; 毛病出在函数GetMemory中。编译器总是要为函数的每个参数制作临时副本，指针参数p的副本是 _p，编译器使 _p=p。如果函数体内的程序修改了_p的内容，就导致参数p的内容作相应的修改。这就是指针可以用作输出参数的原因。在本例中，_p申请了新的内存，只是把 _p所指的内存地址改变了，但是p丝毫未变。所以函数GetMemory并不能输出任何东西。事实上，每执行一次GetMemory就会泄露一块内存，因为没有用free释放内存。 如果非得要用指针参数去申请内存，那么应该改用“指向指针的指针”，见示例：1234567891011void GetMemory2(char **p, int num)&#123; *p = (char *)malloc(sizeof(char) * num);&#125;void Test2(void)&#123; char *str = NULL; GetMemory2(&amp;str, 100); // 注意参数是 &amp;str，而不是str strcpy(str, "hello"); cout&lt;&lt; str &lt;&lt; endl; free(str);&#125; 由于“指向指针的指针”这个概念不容易理解，我们可以用函数返回值来传递动态内存。这种方法更加简单，见示例：123456789101112char *GetMemory3(int num)&#123; char *p = (char *)malloc(sizeof(char) * num); return p;&#125;void Test3(void)&#123; char *str = NULL; str = GetMemory3(100); strcpy(str, "hello"); cout&lt;&lt; str &lt;&lt; endl; free(str);&#125; 用函数返回值来传递动态内存这种方法虽然好用，但是常常有人把return语句用错了。这里强调不要用return语句返回指向“栈内存”的指针，因为该内存在函数结束时自动消亡，见示例：123456789char *GetString(void)&#123; char p[] = "hello world"; return p; // 编译器将提出警告&#125;void Test4(void)&#123; char *str = NULL; str = GetString(); // str 的内容是垃圾 cout&lt;&lt; str &lt;&lt; endl;&#125; 用调试器逐步跟踪Test4，发现执行str = GetString语句后str不再是NULL指针，但是str的内容不是“hello world”而是垃圾。 如果把上述示例改写成如下示例，会怎么样？123456789char *GetString2(void)&#123; char *p = "hello world"; return p;&#125;void Test5(void)&#123; char *str = NULL; str = GetString2(); cout&lt;&lt; str &lt;&lt; endl;&#125; 函数Test5运行虽然不会出错，但是函数GetString2的设计概念却是错误的。因为GetString2内的“hello world”是常量字符串，位于静态存储区，它在程序生命期内恒定不变。无论什么时候调用GetString2，它返回的始终是同一个“只读”的内存块。 杜绝“野指针” “野指针”不是NULL指针，是指向“垃圾”内存的指针。人们一般不会错用NULL指针，因为用if语句很容易判断。但是“野指针”是很危险的，if语句对它不起作用。 “野指针”的成因主要有三种： 指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。例如： 12char *p = NULL;char *str = (char *) malloc(100); 指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。 指针操作超越了变量的作用域范围。 这种情况让人防不胜防，示例程序如下：12345678910class A&#123; public: void Func(void)&#123; cout &lt;&lt; “Func of class A” &lt;&lt; endl; &#125;&#125;;void Test(void)&#123; A *p; A a; p = &amp;a; // 注意 a 的生命期 p-&gt;Func(); // p是“野指针”&#125; 函数Test在执行语句p-&gt;Func()时，对象a已经消失，而p是指向a的，所以p就成了“野指针”。但奇怪的是我运行这个程序时居然没有出错，这可能与编译器有关。 有了malloc/free为什么还要new/delete malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。 对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。 因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。我们先看一看malloc/free和new/delete如何实现对象的动态内存管理，见示例：12345678910111213141516171819class Obj&#123; public : Obj(void)&#123; cout &lt;&lt; “Initialization” &lt;&lt; endl; &#125; ~Obj(void)&#123; cout &lt;&lt; “Destroy” &lt;&lt; endl; &#125; void Initialize(void)&#123; cout &lt;&lt; “Initialization” &lt;&lt; endl; &#125; void Destroy(void)&#123; cout &lt;&lt; “Destroy” &lt;&lt; endl; &#125;&#125;;void UseMallocFree(void)&#123; Obj *a = (obj *)malloc(sizeof(obj)); // 申请动态内存 a-&gt;Initialize(); // 初始化 //… a-&gt;Destroy(); // 清除工作 free(a); // 释放内存&#125;void UseNewDelete(void)&#123; Obj *a = new Obj; // 申请动态内存并且初始化 //… delete a; // 清除并且释放内存&#125; 类Obj的函数Initialize模拟了构造函数的功能，函数Destroy模拟了析构函数的功能。函数UseMallocFree中，由于malloc/free不能执行构造函数与析构函数，必须调用成员函数Initialize和Destroy来完成初始化与清除工作。函数UseNewDelete则简单得多。 所以我们不要企图用malloc/free来完成动态对象的内存管理，应该用new/delete。由于内部数据类型的“对象”没有构造与析构的过程，对它们而言malloc/free和new/delete是等价的。 既然new/delete的功能完全覆盖了malloc/free，为什么C++不把malloc/free淘汰出局呢？这是因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。 如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，结果也会导致程序出错，但是该程序的可读性很差。所以new/delete必须配对使用，malloc/free也一样。 内存耗尽怎么办 如果在申请动态内存时找不到足够大的内存块，malloc和new将返回NULL指针，宣告内存申请失败。通常有三种方式处理“内存耗尽”问题。 判断指针是否为NULL，如果是则马上用return语句终止本函数。 123456void Func(void)&#123; A *a = new A; if(a == NULL) return; …&#125; 判断指针是否为NULL，如果是则马上用exit(1)终止整个程序的运行。 12345678void Func(void)&#123; A *a = new A; if(a == NULL)&#123; cout &lt;&lt; “Memory Exhausted” &lt;&lt; endl; exit(1); &#125; …&#125; 为new和malloc设置异常处理函数。 Visual C++可以用_set_new_hander函数为new设置用户自己定义的异常处理函数，也可以让malloc享用与new相同的异常处理函数。详细内容请参考C++使用手册。 上述 1、2 方式使用最普遍。如果一个函数内有多处需要申请动态内存，那么方式 1 就显得力不从心（释放内存很麻烦），应该用方式 2 来处理。 很多人不忍心用exit(1)，问：“不编写出错处理程序，让操作系统自己解决行不行？” 不行。如果发生“内存耗尽”这样的事情，一般说来应用程序已经无药可救。如果不用exit(1) 把坏程序杀死，它可能会害死操作系统。道理如同：如果不把歹徒击毙，歹徒在老死之前会犯下更多的罪。 有一个很重要的现象要告诉大家。对于32位以上的应用程序而言，无论怎样使用malloc与new，几乎不可能导致“内存耗尽”。对于32位以上的应用程序，“内存耗尽”错误处理程序毫无用处。这下可把Unix和Windows程序员们乐坏了：反正错误处理程序不起作用，我就不写了，省了很多麻烦。 必须强调：不加错误处理将导致程序的质量很差，千万不可因小失大。 123456789void main(void)&#123; float *p = NULL; while(TRUE)&#123; p = new float[1000000]; cout &lt;&lt; “eat memory” &lt;&lt; endl; if(p==NULL) exit(1); &#125;&#125; malloc/free的使用要点 函数malloc的原型如下：1void * malloc(size_t size); 用malloc申请一块长度为length的整数类型的内存，程序如下：1int *p = (int *) malloc(sizeof(int) * length); 我们应当把注意力集中在两个要素上：“类型转换”和“sizeof”。 malloc返回值的类型是void *，所以在调用malloc时要显式地进行类型转换，将void *转换成所需要的指针类型。 malloc函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。我们通常记不住int, float等数据类型的变量的确切字节数。例如int变量在16位系统下是2个字节，在32位下是4个字节；而float变量在16位系统下是4个字节，在32位下也是4个字节。最好用以下程序作一次测试：12345678cout &lt;&lt; sizeof(char) &lt;&lt; endl;cout &lt;&lt; sizeof(int) &lt;&lt; endl;cout &lt;&lt; sizeof(unsigned int) &lt;&lt; endl;cout &lt;&lt; sizeof(long) &lt;&lt; endl;cout &lt;&lt; sizeof(unsigned long) &lt;&lt; endl;cout &lt;&lt; sizeof(float) &lt;&lt; endl;cout &lt;&lt; sizeof(double) &lt;&lt; endl;cout &lt;&lt; sizeof(void *) &lt;&lt; endl; 在malloc的“()”中使用sizeof运算符是良好的风格，但要当心有时我们会昏了头，写出 p = malloc(sizeof(p))这样的程序来。 函数free的原型如下：1void free( void * memblock ); 为什么free函数不象malloc函数那样复杂呢？这是因为指针p的类型以及它所指的内存的容量事先都是知道的，语句free(p)能正确地释放内存。如果p是NULL指针，那么free对p无论操作多少次都不会出问题。如果p不是NULL指针，那么free对p连续操作两次就会导致程序运行错误。 new/delete的使用要点 运算符new使用起来要比函数malloc简单得多，例如：12int *p1 = (int *)malloc(sizeof(int) * length);int *p2 = new int[length]; 这是因为new内置了sizeof、类型转换和类型安全检查功能。对于非内部数据类型的对象而言，new在创建动态对象的同时完成了初始化工作。如果对象有多个构造函数，那么new的语句也可以有多种形式。例如：12345678910111213class Obj&#123; public : Obj(void); // 无参数的构造函数 Obj(int x); // 带一个参数的构造函数 …&#125;void Test(void)&#123; Obj *a = new Obj; Obj *b = new Obj(1); // 初值为1 … delete a; delete b;&#125; 如果用new创建对象数组，那么只能使用对象的无参数构造函数。例如：1Obj *objects = new Obj[100]; // 创建100个动态对象 不能写成：1Obj *objects = new Obj[100](1);// 创建100个动态对象的同时赋初值1 在用delete释放对象数组时，留意不要丢了符号‘[]’。例如：12delete []objects; // 正确的用法delete objects; // 错误的用法 后者有可能引起程序崩溃和内存泄漏。 Conclusion]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法之应用]]></title>
    <url>%2F2018%2F04%2F12%2Falgorithm-application%2F</url>
    <content type="text"><![CDATA[递归(Recursive):当一个函数用它自己来定义时就称为时递归。阶乘、斐波那契数列和汉诺塔，帕斯卡三角形，也就是著名的杨辉三角1234567void recursion_loop(int i) &#123; if (i == 10) return; else recursion_loop(i + 1);&#125;// 调用： recursion_loop(0); 取幂运算：计算x的N次方常见的算法是N-1次乘法自乘递归的基准条件是：N==0 此时返回1（不调用自身）。若N是偶数，则x的N次方等于 xx的N/2次方。若N是奇数，则x的N次方等于 xx的N/2次方在乘以x。时间复杂度：O($\log_2 n$)123456789101112long int pow(long int x, unsigned int n) &#123; if (n == 0) return 1; if (n == 1) return x; if ((x &amp; 1) == 0) &#123; // 偶数 return pow(x * x, n / 2); &#125; else &#123;// return pow(x * x, n / 2) * x; return pow(x, n - 1) * x; &#125;&#125; 阶乘：0!=1，n!=(n-1)!×n123static long factorial(const long n) &#123; return 0 == n || 1 == n ? 1 : n * factorial(n - 1);&#125; 斐波那契数列(Fibonacci)：又称黄金分割数列,以递归的方法定义：F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）1, 1, 2, 3, 5, 8, 13, 21, 34…这个数列从第3项开始，每一项都等于前两项之和。123static long fib(const long n) &#123; return 0 == n || 1 == n ? 1 : fib(n - 1) + fib(n - 2);&#125; 汉诺塔：假设有n片，移动次数是f(n).显然f(1)=1,f(2)=3,f(3)=7，且f(k+1)=2*f(k)+1 (等比数列)。此后不难证明f(n)=$2^n$-1。123456789101112static void move(const char x, const int n, const char z) &#123; printf(&quot;把圆盘 %d 从柱子 %c 移动到 %c 上\n&quot;, n, x, z);&#125;static void hanoi(const int n, const char x, const char y, const char z) &#123; if (1 == n) move(x, 1, z); // 如果只有一个盘，则直接将它从x移动到z else &#123; hanoi(n - 1, x, z, y); // 把1 ~ n - 1个盘从x移动到y，用z作为中转 move(x, n, z); // 把第n个盘从x移动到z hanoi(n - 1, y, x, z); // 把1 ~ n - 1个盘从y移动到z，用x作为中转 &#125;&#125; 帕斯卡三角形，也就是著名的杨辉三角1234511 11 2 11 3 3 11 4 6 4 1 三角形边界上的数都是1，内部的每个数是位于它上面的两个数之和。利用递归我们可以很容易地把问题转换为这个性质：假设f(row, col)表示杨辉三角的第row行的第col个元素，那么： f(row, col) = 1 (col = 1 或者 row = col)，也就是递归的停止条件。 f(row, col) = f(row - 1, col - 1) + f(row - 1, col)，也就是上一行的两个相邻元素的和。123456789101112131415static long GetElement(const long row, const long col) &#123; if ((1 == col) || (row == col)) // 每行的外围两个元素为1 return 1; else // 其余的部分为上一行的(col - 1)和(col)元素之和 return GetElement(row - 1, col - 1) + GetElement(row - 1, col);&#125;static long PascalTriangle(const long n) &#123; int row; int col; for (row = 1; row &lt;= n; ++row) &#123; for (col = 1; col &lt;= row; ++col) printf(&quot; %4ld&quot;, GetElement(row, col)); printf(&quot;\n&quot;); &#125;&#125; 求两个整数的最大公约数。最大公因数：同时整除两个整数的最大整数。 两个数的乘积等于两个数的最大公约数和最小公倍数的乘积。 如果N整除A-B，那么我们就说A与B模N同余。 最小公倍数 = (a * b)/最大公约数 1234567891011121314151617181920212223242526272829303132// 1.直接遍历法int maxCommonDivisor(int a, int b) &#123; int max = 0; for (int i = 1; i &lt;=b; i++) &#123; if (a % i == 0 &amp;&amp; b % i == 0) &#123; max = i; &#125; &#125; return max;&#125;// 2.辗转相除法int maxCommonDivisor(int a, int b) &#123; int r; while(a % b &gt; 0) &#123; r = a % b; a = b; b = r; &#125; return b;&#125;// 3.欧几里得算法计算最大公因数int gcd(int m, int n) &#123; int rem; while (n &gt; 0) &#123; rem = m % n; m = n; n = rem; &#125; return m;&#125; 不用中间变量,用两种方法交换A和B的值1234567891011121314151617181920// 1.中间变量void swap(int a, int b) &#123; int temp = a; a = b; b = temp;&#125;// 2.加法void swap(int a, int b) &#123; a = a + b; b = a - b; a = a - b;&#125;// 3.异或（相同为0，不同为1. 可以理解为不进位加法）void swap(int a, int b) &#123; a = a ^ b; b = a ^ b; a = a ^ b;&#125; 实现一个字符串“how are you”的逆序输出（编程语言不限）。如给定字符串为“hello world”,输出结果应当为“world hello”。123456789101112131415161718192021222324int spliterFunc(char *p) &#123; char c[100][100]; int i = 0; int j = 0; while (*p != &apos;\0&apos;) &#123; if (*p == &apos; &apos;) &#123; i++; j = 0; &#125; else &#123; c[i][j] = *p; j++; &#125; p++; &#125; for (int k = i; k &gt;= 0; k--) &#123; printf(&quot;%s&quot;, c[k]); if (k &gt; 0) &#123; printf(&quot; &quot;); &#125; else &#123; printf(&quot;\n&quot;); &#125; &#125; return 0; 给定一个字符串，输出本字符串中只出现一次并且最靠前的那个字符的位置？如“abaccddeeef”,字符是b,输出应该是2。12345678910111213141516171819202122232425262728293031323334353637 char *strOutPut(char *);int compareDifferentChar(char, char *);int main(int argc, const char * argv[]) &#123; char *inputStr = &quot;abaccddeeef&quot;; char *outputStr = strOutPut(inputStr); printf(&quot;%c \n&quot;, *outputStr); return 0;&#125;char *strOutPut(char *s) &#123; char str[100]; char *p = s; int index = 0; while (*s != &apos;\0&apos;) &#123; if (compareDifferentChar(*s, p) == 1) &#123; str[index] = *s; index++; &#125; s++; &#125; return &amp;str;&#125;int compareDifferentChar(char c, char *s) &#123; int i = 0; while (*s != &apos;\0&apos; &amp;&amp; i&lt;= 1) &#123; if (*s == c) &#123; i++; &#125; s++; &#125; if (i == 1) &#123; return 1; &#125; else &#123; return 0; &#125;&#125; 二叉树遍历二叉树的先序遍历为FBACDEGH,中序遍历为：ABDCEFGH,请写出这个二叉树的后序遍历结果。ADECBHGF 先序+中序遍历还原二叉树：先序遍历是：ABDEGCFH 中序遍历是：DBGEACHF首先从先序得到第一个为A，就是二叉树的根，回到中序，可以将其分为三部分：左子树的中序序列DBGE，根A，右子树的中序序列CHF接着将左子树的序列回到先序可以得到B为根，这样回到左子树的中序再次将左子树分割为三部分：左子树的左子树D，左子树的根B，左子树的右子树GE同样地，可以得到右子树的根为C类似地将右子树分割为根C，右子树的右子树HF，注意其左子树为空如果只有一个就是叶子不用再进行了，刚才的GE和HF再次这样运作，就可以将二叉树还原了。后序遍历：DGEBHFCA 打印2-100之间的素数。质数大于等于2 不能被它本身和1以外的数整除在一般领域，对正整数n，如果用2到 之间的所有整数去除，均无法整除，则n为质数。1234567891011121314151617 int main(int argc, const char * argv[]) &#123; for (int i = 2; i &lt; 100; i++) &#123; int r = isPrime(i); if (r == 1) &#123; printf(&quot;%ld &quot;, i); &#125; &#125; return 0;&#125;int isPrime(int n)&#123; int i, s; for(i = 2; i &lt;= sqrt(n); i++) if(n % i == 0) return 0; return 1;&#125; 给一列无序数组，求出中位数并给出算法的时间复杂度。若数组有奇数个元素，中位数是a[(n-1)/2]；若数组有偶数个元素，中位数为a[n/2-1]和a[n/2]两个数的平均值。这里为方便起见，假设数组为奇数个元素。 思路一：把无序数组排好序，取出中间的元素。时间复杂度取决于排序算法，最快是快速排序，O(nlogn)，或者是非比较的基数排序，时间为O(n),空间为O(n)。这明显不是我们想要的。 思路二：采用快速排序的分治partition过程。任意挑一个元素，以该元素为支点，将数组分成两部分，左边是小于等于支点的，右边是大于支点的。如果左侧长度正好是(n - 1)/2，那么支点恰为中位数。如果左侧长度&lt;(n-1)/2, 那么中位数在右侧，反之，中位数在左侧。 进入相应的一侧继续寻找中位数。 1234567891011121314151617181920212223242526272829303132// 快速排序的分治过程找无序数组的中位数 int partition(int a[], int low, int high) //快排的一次排序过程&#123; int q = a[low]; while (low &lt; high) &#123; while (low &lt; high &amp;&amp; a[high] &gt;= q) high--; a[low] = a[high]; while (low &lt; high &amp;&amp; a[low] &lt;= q) low++; a[high] = a[low]; &#125; a[low] = q; return low;&#125;int findMidium(int a[], int n)&#123; int index = n / 2; int left = 0; int right = n - 1; int q = -1; while (index != q) &#123; q = partition(a, left, right); if (q &lt; index) left = q + 1; else if (q&gt;index) right = q - 1; &#125; return a[index];&#125; 思路三：将数组的前（n+1）／2个元素建立一个最小堆。然后，对于下一个元素，和堆顶的元素比较，如果小于等于，丢弃之，如果大于，则用该元素取代堆顶，再调整堆，接着看下一个元素。重复这个步骤，直到数组为空。当数组都遍历完了，（堆中元素为最大的（n+1）／2个元素，）堆顶的元素即是中位数。 12345678910111213141516171819202122232425262728293031323334353637383940414243 //构建最小堆找无序数组的中位数 void nswap(int&amp; i, int&amp; j)&#123; i = i^j; j = i^j; i = i^j;&#125;void minHeapify(int a[], int i, int len)&#123; int temp; int least = i; int l = i * 2 + 1; int r = i * 2 + 2; if (l &lt; len &amp;&amp; a[l] &lt; a[least]) least = l; if (r &lt; len &amp;&amp; a[r] &lt; a[least]) least = r; if (least != i) &#123; nswap(a[i], a[least]); minHeapify(a, least, len); &#125;&#125;void buildMinHeap(int a[], int len)&#123; for (int i = (len-2) / 2; i &gt;= 0; i--) &#123; minHeapify(a, i, len); &#125;&#125;int findMidium2(int a[], int n)&#123; buildMinHeap(a, (n + 1) / 2); for (int i = (n + 1) / 2; i &lt; n; i++) &#123; if (a[i] &gt; a[0]) &#123; nswap(a[i], a[0]); minHeapify(a, 0,(n + 1) / 2); &#125; &#125; return a[0];&#125; 引申一：查找N个元素中的第K个小的元素编程珠玑给出了一个时间复杂度O（N）的解决方案。该方案改编自快速排序。经过快排的一次划分， 1）如果左半部份的长度&gt;K-1，那么这个元素就肯定在左半部份了 2）如果左半部份的长度==K-1，那么当前划分元素就是结果了。 3）如果。。。。。。。&lt;K-1,那么这个元素就肯定在右半部分了。并且，该方法可以用尾递归实现。效率更高。也可以用来查找N个元素中的前K个小的元素，前K个大的元素。。。。等等。 引申二：查找N个元素中的第K个小的元素，假设内存受限，仅能容下K/4个元素。分趟查找，第一趟，用堆方法查找最小的K/4个小的元素，同时记录剩下的N-K/4个元素到外部文件。第二趟，用堆方法从第一趟筛选出的N-K/4个元素中查找K/4个小的元素，同时记录剩下的N-K/2个元素到外部文件。。。。第四趟，用堆方法从第一趟筛选出的N-K/3个元素中查找K/4个小的元素，这是的第K/4小的元素即使所求。 输入一个整型数组，求出子数组和的最大值，并给出算法的时间复杂度。设b[i]表示a[0…i]的子数组和的最大值，且b[i]一定包含a[i]，即：sum为子问题的最优解， 包含a[i],即求b[i]的最大值，在计算b[i]时,可以考虑以下两种情况,因为a[i]要求一定包含在内，所以 1) 当b[i-1]&gt;0, b[i] = b[i-1]+a[i] 2) 当b[i-1]&lt;=0, b[i] = a[i], 当b[i-1]&lt;=0，这时候以a[i]重新作为b[i]的起点。 不包含a[i],即a[0]~a[i-1]的最大值（即0~i-1局部问题的最优解),设为sum最后比较b[i]和 sum，即,如果b[i] &gt;sum ,即b[i]为最优解,然后更新sum的值.在实现时，bMax代表 b[k], sum更新前代表前一步子问题的最优解，更新后代表当前问题的最优解。实现如下： 123456789101112131415161718192021222324252627282930//求数组的子数组和的最大值，时间复杂度为O(n) int maxSumArr(int a[], int n,int* start, int* end)&#123; int s, e; int sum = a[0]; int bMax=a[0]; *start = *end = 0; for (int i = 1; i &lt; n; i++) &#123; if (bMax &gt; 0) //情况一，子数组包含a[i]，且b[i-1]&gt;0（上一次的最优解大于0），b[i] = b[i-1]+a[i] &#123; bMax += a[i]; e = i; &#125; else //情况二，子数组包含a[i]，且b[i-1]&lt;=0（上一次的最优解小于0），这时候以a[i]重新作为b[i]的起点。 &#123; bMax = a[i]; s = i; e = i; &#125; //情况三，子数组不包含a[i],即b[i]=sum if (bMax &gt; sum) //三种情况相比较，最大值作为更新后的最优解，存在sum &#123; sum = bMax; *start = s; *end = e; &#125; &#125; return sum;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法之查找]]></title>
    <url>%2F2018%2F04%2F10%2Falgorithm-search%2F</url>
    <content type="text"><![CDATA[1. 顺序查找说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。 基本思想：顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。 复杂度分析：查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL = 1/n(1+2+3+…+n) = (n+1)/2 ;当查找不成功时，需要n+1次比较，时间复杂度为O(n); 所以，顺序查找的时间复杂度为O(n)。123456789//顺序查找int SequenceSearch(int a[], int value, int n)&#123; int i; for(i=0; i&lt;n; i++) if(a[i]==value) return i; return -1;&#125; 2. 二分查找说明：元素必须是有序的，如果是无序的则要先进行排序操作。 基本思想：也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。 复杂度分析：最坏情况下，关键词比较次数为$\log_2 (n+1)$，且期望时间复杂度为O($\log_2 n$)；注：折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。123456789101112131415161718192021222324252627282930//二分查找（折半查找），版本1int BinarySearch1(int a[], int value, int n)&#123; int low, high, mid; low = 0; high = n-1; while(low&lt;=high) &#123; mid = (low+high)/2; if(a[mid]==value) return mid; if(a[mid]&gt;value) high = mid-1; if(a[mid]&lt;value) low = mid+1; &#125; return -1;&#125;//二分查找，递归版本int BinarySearch2(int a[], int value, int low, int high)&#123; int mid = low+(high-low)/2; if(a[mid]==value) return mid; if(a[mid]&gt;value) return BinarySearch2(a, value, low, mid-1); if(a[mid]&lt;value) return BinarySearch2(a, value, mid+1, high);&#125; 3. 插值查找说明：在介绍插值查找之前，首先考虑一个新问题，为什么上述算法一定要是折半，而不是折四分之一或者折更多呢？打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是一定目的的往前或往后翻。同样的，比如要在取值范围1 ~ 10000 之间 100 个元素从小到大均匀分布的数组中查找5，我们自然会考虑从数组下标较小的开始查找。经过以上分析，折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。二分查找中查找点计算如下：mid=(low+high)/2, 即mid=low+1/2(high-low);通过类比，我们可以将查找的点改进为如下：mid=low+(key-a[low])/(a[high]-a[low])(high-low)也就是将上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。 基本思想：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。 复杂度分析：查找成功或者失败的时间复杂度均为O($\log_2 (log_2 n)$)。 1234567891011//插值查找int InsertionSearch(int a[], int value, int low, int high)&#123; int mid = low+(value-a[low])/(a[high]-a[low])*(high-low); if(a[mid]==value) return mid; if(a[mid]&gt;value) return InsertionSearch(a, value, low, mid-1); if(a[mid]&lt;value) return InsertionSearch(a, value, mid+1, high);&#125; 4. 斐波那契查找说明：在介绍斐波那契查找算法之前，我们先介绍一下很它紧密相连并且大家都熟知的一个概念——黄金分割。黄金比例又称黄金分割，是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为1:0.618或1.618:1。 斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….（从第三个数开始，后边每一个数都是前两个数的和）。在数学上，斐波纳契数列以如下被以递归的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）然后我们会发现，随着斐波那契数列的递增，前后两个数的比值会越来越接近0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中。 基本思想：也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。相对于折半查找，一般将待比较的key值与第mid=（low+high）/2位置的元素比较，比较结果分三种情况：1）相等，mid位置的元素即为所求2）&gt;，low=mid+1;3）&lt;，high=mid-1。斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。他要求开始表中记录的个数为某个斐波那契数小1，及n=F(k)-1;开始将k值与第F(k-1)位置的记录进行比较(及mid=low+F(k-1)-1),比较结果也分为三种1）相等，mid位置的元素即为所求2）&gt;，low=mid+1,k-=2;说明：low=mid+1说明待查找的元素在[mid+1,high]范围内，k-=2 说明范围[mid+1,high]内的元素个数为n-(F(k-1))= Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个，所以可以递归的应用斐波那契查找。3）&lt;，high=mid-1,k-=1。说明：low=mid+1说明待查找的元素在[low,mid-1]范围内，k-=1 说明范围[low,mid-1]内的元素个数为F(k-1)-1个，所以可以递归 的应用斐波那契查找。 复杂度分析：最坏情况下，时间复杂度为O($\log_2 n$)，且其期望复杂度也为O($\log_2 n$)。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 斐波那契查找.cpp #include &quot;stdafx.h&quot;#include &lt;memory&gt;#include &lt;iostream&gt;using namespace std;const int max_size=20;//斐波那契数组的长度/*构造一个斐波那契数组*/ void Fibonacci(int * F)&#123; F[0]=0; F[1]=1; for(int i=2; i&lt;max_size; ++i) F[i]=F[i-1]+F[i-2];&#125;/*定义斐波那契查找法*/ int FibonacciSearch(int *a, int n, int key) //a为要查找的数组,n为要查找的数组长度,key为要查找的关键字&#123; int low=0; int high=n-1; int F[max_size]; Fibonacci(F);//构造一个斐波那契数组F int k=0; while(n&gt;F[k]-1)//计算n位于斐波那契数列的位置 ++k; int * temp;//将数组a扩展到F[k]-1的长度 temp=new int [F[k]-1]; memcpy(temp,a,n*sizeof(int)); for(int i=n;i&lt;F[k]-1;++i) temp[i]=a[n-1]; while(low&lt;=high) &#123; int mid=low+F[k-1]-1; if(key&lt;temp[mid]) &#123; high=mid-1; k-=1; &#125; else if(key&gt;temp[mid]) &#123; low=mid+1; k-=2; &#125; else &#123; if(mid&lt;n) return mid; //若相等则说明mid即为查找到的位置 else return n-1; //若mid&gt;=n则说明是扩展的数值,返回n-1 &#125; &#125; delete [] temp; return -1;&#125;int main()&#123; int a[] = &#123;0,16,24,35,47,59,62,73,88,99&#125;; int key=100; int index=FibonacciSearch(a,sizeof(a)/sizeof(int),key); cout&lt;&lt;key&lt;&lt;&quot; is located at:&quot;&lt;&lt;index; return 0;&#125; 5. 树表查找说明：5.1 最简单的树表查找算法——二叉树查找算法。 基本思想：二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。二叉查找树（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree）或者是一棵空树，或者是具有下列性质的二叉树： 1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 3）任意节点的左、右子树也分别为二叉查找树。二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。有关二叉查找树的查找、插入、删除等操作的详细讲解，请移步浅谈算法和数据结构: 二叉查找树 复杂度分析：它和二分查找一样，插入和查找的时间复杂度均为O($\log_2 n$)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行n次查找操作）。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。基于二叉查找树进行优化，进而可以得到其他的树表查找算法，如平衡树、红黑树等高效算法。 5.2 平衡查找树之2-3查找树（2-3 Tree） 2-3查找树定义：和二叉树不一样，2-3树运行每个节点保存1个或者两个的值。对于普通的2节点(2-node)，他保存1个key和左右两个自己点。对应3节点(3-node)，保存两个Key，2-3查找树的定义如下： 1）要么为空，要么： 2）对于2节点，该节点保存一个key及对应value，以及两个指向左右节点的节点，左节点也是一个2-3节点，所有的值都比key要小，右节点也是一个2-3节点，所有的值比key要大。 3）对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。 2-3查找树的性质： 1）如果中序遍历2-3查找树，就可以得到排好序的序列； 2）在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。（这也是平衡树中“平衡”一词的概念，根节点到叶节点的最长距离对应于查找算法的最坏情况，而平衡树中根节点到叶节点的距离都一样，最坏情况也具有对数复杂度。）复杂度分析：2-3树的查找效率与树的高度是息息相关的。 在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为lgN 在最好的情况下，所有的节点都是3-node节点，查找效率为log3N约等于0.631lgN, 距离来说，对于1百万个节点的2-3树，树的高度为12-20之间，对于10亿个节点的2-3树，树的高度为18-30之间。对于插入来说，只需要常数次操作即可完成，因为他只需要修改与该节点关联的节点即可，不需要检查其他节点，所以效率和查找类似。下面是2-3查找树的效率： 5.3 平衡查找树之红黑树（Red-Black Tree） 2-3查找树能保证在插入元素之后能保持树的平衡状态，最坏情况下即所有的子节点都是2-node，树的高度为lgn，从而保证了最坏情况下的时间复杂度。但是2-3树实现起来比较复杂，于是就有了一种简单实现2-3树的数据结构，即红黑树（Red-Black Tree）。 基本思想：红黑树的思想就是对2-3查找树进行编码，尤其是对2-3查找树中的3-nodes节点添加额外的信息。红黑树中将节点之间的链接分为两种不同类型，红色链接，他用来链接两个2-nodes节点来表示一个3-nodes节点。黑色链接用来链接普通的2-3节点。特别的，使用红色链接的两个2-nodes来表示一个3-nodes节点，并且向左倾斜，即一个2-node是另一个2-node的左子节点。这种做法的好处是查找的时候不用做任何修改，和普通的二叉查找树相同。 红黑树的定义：红黑树是一种具有红色和黑色链接的平衡查找树，同时满足： 红色节点向左倾斜 一个节点不可能有两个红色链接 整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。 下图可以看到红黑树其实是2-3树的另外一种表现形式：如果我们将红色的连线水平绘制，那么他链接的两个2-node节点就是2-3树中的一个3-node节点了。红黑树的性质：整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同（2-3树的第2）性质，从根节点到叶子节点的距离都相等）。复杂度分析：最坏的情况就是，红黑树中除了最左侧路径全部是由3-node节点组成，即红黑相间的路径长度是全黑路径长度的2倍。红黑树的平均高度大约为logn。红黑树这种数据结构应用十分广泛，在多种编程语言中被用作符号表的实现，如： Java中的java.util.TreeMap,java.util.TreeSet； C++ STL中的：map,multimap,multiset； .NET中的：SortedDictionary,SortedSet 等。 5.4 B树和B+树（B Tree/B+ Tree）平衡查找树中的2-3树以及其实现红黑树。2-3树种，一个节点最多有2个key，而红黑树则使用染色的方式来标识这两个key。维基百科对B树的定义为“在计算机科学中，B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。 B树定义：B树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。 根节点至少有两个子节点 每个节点有M-1个key，并且以升序排列 位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间 其它节点至少有M/2个子节点可以看到B树是2-3树的一种扩展，他允许一个节点有多于2个的元素。B树的插入及平衡化操作和2-3树很相似 B+树定义：B+树是对B树的一种变形树，它与B树的差异在于： 有k个子结点的结点必然有k个关键码； 非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。 树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。 B和B+树的区别B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。B+ 树的优点在于： 由于B+树在内部节点上不好含数据信息，因此在内存页中能够存放更多的key。数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。 B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。 B/B+树常用于文件系统和数据库系统中，它通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存储的空间局部性从而减少IO操作。它广泛用于文件系统及数据库中，如： Windows：HPFS文件系统； Mac：HFS，HFS+文件系统； Linux：ResiserFS，XFS，Ext3FS，JFS文件系统； 数据库：ORACLE，MYSQL，SQLSERVER等中。有关B/B+树在数据库索引中的应用，请看张洋的MySQL索引背后的数据结构及算法原理这篇文章，这篇文章对MySQL中的如何使用B+树进行索引有比较详细的介绍，推荐阅读。 树表查找总结：二叉查找树平均查找性能不错，为O(logn)，但是最坏情况会退化为O(n)。在二叉查找树的基础上进行优化，我们可以使用平衡查找树。平衡查找树中的2-3查找树，这种数据结构在插入之后能够进行自平衡操作，从而保证了树的高度在一定的范围内进而能够保证最坏情况下的时间复杂度。但是2-3查找树实现起来比较困难，红黑树是2-3树的一种简单高效的实现，他巧妙地使用颜色标记来替代2-3树中比较难处理的3-node节点问题。红黑树是一种比较高效的平衡查找树，应用非常广泛，很多编程语言的内部实现都或多或少的采用了红黑树。除此之外，2-3查找树的另一个扩展——B/B+平衡树，在文件系统和数据库系统中有着广泛的应用。 6. 分块查找说明：分块查找又称索引顺序查找，它是顺序查找的一种改进方法。 基本思想：将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素， 复杂度分析：算法流程： step1 先选取各块中的最大关键字构成一个索引表； step2 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。 7. 哈希查找说明：什么是哈希表（Hash）？ 我们使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素”分类”，然后将这个元素存储在相应”类”所对应的地方。但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了”冲突”，换句话说，就是把不同的元素分在了相同的”类”之中。后面我们将看到一种解决”冲突”的简便做法。 总的来说，”直接定址”与”解决冲突”是哈希表的两大特点。什么是哈希函数？ 哈希函数的规则是：通过某种转换关系，使关键字适度的分散到指定大小的的顺序结构中，越分散，则以后查找的时间复杂度越小，空间复杂度越高。 基本思想：哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。 算法流程：1）用给定的哈希函数构造哈希表；2）根据选择的冲突处理方法解决地址冲突；常见的解决冲突的方法：拉链法和线性探测法。详细的介绍可以参见：浅谈算法和数据结构: 十一 哈希表。3）在哈希表的基础上执行哈希查找。哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。 复杂度分析：单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)（注意，在查找之前我们需要构建相应的Hash表）。 使用Hash，我们付出了什么？ 我们在实际编程中存储一个大规模的数据，最先想到的存储结构可能就是map，也就是我们常说的KV pair，经常使用Python的博友可能更有这种体会。使用map的好处就是，我们在后续处理数据处理时，可以根据数据的key快速的查找到对应的value值。map的本质就是Hash表，那我们在获取了超高查找效率的基础上，我们付出了什么？ Hash是一种典型以空间换时间的算法，比如原来一个长度为100的数组，对其查找，只需要遍历且匹配相应记录即可，从空间复杂度上来看，假如数组存储的是byte类型数据，那么该数组占用100byte空间。现在我们采用Hash算法，我们前面说的Hash必须有一个规则，约束键与存储位置的关系，那么就需要一个固定长度的hash表，此时，仍然是100byte的数组，假设我们需要的100byte用来记录键与位置的关系，那么总的空间为200byte,而且用于记录规则的表大小会根据规则，大小可能是不定的。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法之排序]]></title>
    <url>%2F2018%2F04%2F09%2Falgorithm-sort%2F</url>
    <content type="text"><![CDATA[排序分为内部排序和外部排序，内部排序指待排序的记录在内存中，外部排序的记录数量很大，以至于内存放不下而放在外存中，排序过程需要访问外存。这里仅介绍内部排序，包括插入排序、交换排序、选择排序、归并排序、基数排序。 插入排序1，直接插入排序：就是检查第i个数字，如果在它的左边的数字比它大，进行交换，这个动作一直继续下去，直到这个数字的左边数字比它还要小，就可以停止了。插入排序法主要的回圈有两个变数：i和j，每一次执行这个回圈，就会将第i个数字放到左边恰当的位置去。时间复杂度：O($n^2$) // 直接插入 从小到大排序1234567891011void insertSort(int a[], int n) &#123; for(int i = 1; i &lt; n; i++) &#123; int tmp = a[i]; int j = i - 1; while((a[j] &gt; tmp) &amp;&amp; (j &gt;= 0)) &#123; a[j+1] = a[j]; j--; &#125; a[j+1] = tmp; &#125;&#125; // 直接插入12345678910void insertSort(int a[], int n) &#123; for(int i = 1; i &lt; n; i++) &#123; int tmp = a[i]; int j = i - 1; for (; j &gt;= 0 &amp;&amp; a[j] &gt; tmp; j--) &#123; a[j+1] = a[j]; &#125; a[j+1] = tmp; &#125; &#125; 2，折半插入排序（binary insertion sort）：当直接插入进行到某一趟时，对于a[i]来讲，前面i－1个记录已经按关键字有序。此时不用直接插入排序的方法，而改为折半查找，找出a[i]应插入的位置。时间复杂度：O($n^2$) // 折半插入 从小到大排序12345678910111213141516171819void binaryInsertSort(int a[], int n) &#123; for (int i = 1; i &lt; n; i++) &#123; int tmp = a[i]; int low = 0; int high = i - 1; while (low &lt;= high) &#123; int middle = (low + high) / 2; if (tmp &lt; a[middle]) &#123; high = middle - 1; &#125; else &#123; low = middle + 1; &#125; &#125; for (int j = i-1; j &gt;= low; j--) &#123; a[j+1] = a[j]; &#125; a[low] = tmp; &#125;&#125; 3，希尔排序：“缩小增量”的排序方法，初期选用增量较大间隔比较，然后增量缩小，最后为1，希尔排序对增量序列没有严格规定。时间复杂度：O($n^(1.3)$) // 希尔排序 从小到大排序123456789101112131415void shellSort(int a[], int n) &#123; int k = n / 2; while (k &gt; 0) &#123; for (int i = k; i &lt; n; i++) &#123; int tmp = a[i]; int j = i - k; while ((a[j] &gt; tmp) &amp;&amp; (j &gt;= 0)) &#123; a[j+k] = a[j]; j -= k; &#125; a[j+k] = tmp; &#125; k /= 2; &#125;&#125; 交换排序1，冒泡排序：面对一排数据，先从前往后两两比较，如果前一个数比后一个数大就交换两者的顺序，即第一个数和第二个数比，第二个数和第三个数比，……,倒数第二个数和最后一个数比，这样一轮下来以后最大的数就排到最后；接着把除去最大的数的该组数据进行同样的操作，直至这组数只剩下一个，排序结束。时间复杂度：O($n^2$) // 冒泡排序1234567891011void bubbleSort(int a[] , int n) &#123; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n-i-1; j++) &#123; // 比较两个相邻的元素 if(a[j] &gt; a[j+1]) &#123; int t = a[j]; a[j] = a[j+1]; a[j+1] = t; &#125; &#125; &#125;&#125; 2，快速排序：选取一个基准元素(通常已需要排序的数组第一个数)，然后通过一趟排序将比基准数大的放在右边，比基准数小的放在左边，接着对划分好的两个数组再进行上述的排序。快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。时间复杂度：O(n$\log_2 n$) 挖坑填数进行总结1)．i = left; j = right; 将基准数挖出形成第一个坑a[i]。2)．j- -由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。3)．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。4)．再重复执行2，3二步，直到i==j，将基准数填入a[i]中。 // 快速排序12345678910111213141516171819202122232425262728void qsort(int a[], int left, int right) &#123; if(left &gt;= right) &#123; // 如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了 return ; &#125; int i = left; int j = right; int key = a[left]; while(i &lt; j) &#123; // 控制在当前组内寻找一遍 while(i &lt; j &amp;&amp; key &lt;= a[j]) &#123; j--; // 向前寻找 &#125; if (i &lt; j) &#123; a[i] = a[j]; // 将比第一个小的移到低端 &#125; while(i &lt; j &amp;&amp; key &gt;= a[i]) &#123; i++; // 向后寻找 &#125; if (i &lt; j) &#123; a[j] = a[i]; // 将比第一个大的移到高端 &#125; &#125; a[i] = key; // 当在当组内找完一遍以后就把中间数key回归 qsort(a, left, i - 1); qsort(a, i + 1, right);&#125; 选择排序1，简单选择排序：面对一排数，假设第一个数是最小的，将第一个数依次与后面的所有数据进行比较，如发现更小的就把该数的下标记录下来，再将这个数与后面的数比较，一轮下来以后如果发现最小的数的下标不是第一个，就与第一个数交换，这样就保证了第一个位置上的数是最小的；对除去第一个数的剩下的数做同样的操作，多轮循环之后，直到剩下最后一个数，排序结束。时间复杂度：O($n^2$) // 简单选择排序123456789101112131415void simpleChoiceSort(int a[], int n) &#123; for(int i = 0; i &lt; n; i++) &#123; int m = i; for(int j = i + 1; j &lt; n; j++) &#123; if(a[j] &lt; a[m]) &#123; // 如果第j个元素比第m个元素小，将j赋值给m m = j; &#125; &#125; if(i != m) &#123; // 交换m和i两个元素的位置 int t = a[i]; a[i] = a[m]; a[m] = t; &#125; &#125;&#125; 2，堆排序（heap sort）：堆有两个性质，一是堆中某个节点的值总是不大于或不小于其父节点的值，二是堆是一棵完全树。以从大到小排序为例，首先要把得到的数组构建为一个最小堆，这样父节点均是小于或者等于子结点，根节点就是最小值，然后让根节点与尾节点交换，这样一次之后，再把前n－1个元素构建出最小根堆，让根结点与第n－2个元素交换，依此类推，得到降序序列。时间复杂度：O(n$\log_2 n$) // 堆排序 从大到小排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 // 以i节点为根，调整为堆的算法，n是节点总数，i节点的子结点为i*2+1,i*2+2void heapMin(int a[], int i, int n) &#123; // tmp保存根节点，j为左孩子编号 int tmp = a[i]; int j = i*2+1; while (j &lt; n) &#123; if (j+1 &lt; n &amp;&amp; a[j+1] &lt; a[j]) &#123; // 在左右孩子中找最小的 j++; &#125; if (a[j] &gt;= tmp) &#123; break; &#125; a[i] = a[j]; i = j; j = i*2+1; &#125; a[i] = tmp;&#125;void heapMax(int a[], int i, int n) &#123; // tmp保存根节点，j为左孩子编号 int tmp = a[i]; int j = i*2+1; for (; j &lt; n; j = j*2+1) &#123; //从i结点的左子结点开始，也就是2i+1处开始 if (j+1 &lt; n &amp;&amp; a[j] &lt; a[j+1]) &#123; //如果左子结点小于右子结点，k指向右子结点 j ++; &#125; if (a[j] &gt; tmp) &#123; //如果子节点大于父节点，将子节点值赋给父节点（不用进行交换） a[i] = a[j]; i = j; &#125; else &#123; break; &#125; &#125; a[i] = tmp; //将tmp值放到最终的位置&#125;void heapSort(int a[], int n) &#123; // n/2-1最后一个非叶子节点 // 下面这个操作是建立最小堆 for (int i = n/2-1; i &gt;= 0; i--) &#123; heapMin(a, i, n); &#125; // for语句为输出堆顶元素，调整堆操作 for (int j = n-1; j &gt;= 1; j--) &#123; // 堆顶与堆尾交换 int tmp = a[0]; a[0] = a[j]; a[j] = tmp; heapMin(a, 0, j); &#125; // 得到的就是降序序列 for (int i = 0; i &lt; n; i++) &#123; printf(" %d", a[i]); &#125;&#125; 归并排序（merge sort）1，两路归并排序（Merge Sort）：也就是我们常说的归并排序，也叫合并排序。归并操作即将两个顺序序列合并成一个顺序序列的方法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 最差时间复杂度：O(n$\log_2 n$)平均时间复杂度：O(n$\log_2 n$)最差空间复杂度：O(n)稳定性：稳定 归并操作的基本步骤如下：1.申请两个与已经排序序列相同大小的空间，并将两个序列拷贝其中；2.设定最初位置分别为两个已经拷贝排序序列的起始位置，比较两个序列元素的大小，依次选择相对小的元素放到原始序列；3.重复2直到某一拷贝序列全部放入原始序列，将另一个序列剩下的所有元素直接复制到原始序列尾。 设归并排序的当前区间是a[low..high]，分治法的三个步骤是：1.分解：将当前区间一分为二，即求分裂点2.求解：递归地对两个子区间a[low..mid]和a[mid+1..high]进行归并排序；3.组合：将已排序的两个子区间a[low..mid]和a[mid+1..high]归并为一个有序的区间a[low..high]。递归的终结条件：子区间长度为1（一个记录自然有序）。 // 归并子算法123456789101112131415161718192021222324252627282930313233343536 // 将有序的a[low...mid]和a[mid+1...high]归并为有序的tmp[low...high]void merge(int a[], int tmp[], int low, int mid, int high) &#123; int i = low; int j = mid + 1; int k = low; while (i != mid + 1 &amp;&amp; j != high + 1) &#123; if (a[i] &gt;= a[j]) &#123; tmp[k++] = a[j++]; &#125; else &#123; tmp[k++] = a[i++]; &#125; &#125; while (i != mid + 1) &#123; tmp[k++] = a[i++]; &#125; while (j != high + 1) &#123; tmp[k++] = a[j++]; &#125; for (i = low; i &lt;= high; i++) &#123; a[i] = tmp[i]; &#125;&#125;// 两路归并排序void mergeSort(int a[], int tmp[], int low, int high) &#123; if (low &lt; high) &#123; int mid = (low + high) / 2; mergeSort(a, tmp, low, mid); mergeSort(a, tmp, mid + 1, high); merge(a, tmp, low, mid, high); &#125;&#125; 基数排序（radix sort）时间复杂度：O(d(r+n))，r代表关键字的基数，d代表长度，n代表关键字的个数。 又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。 最高位优先(Most Significant Digit first)法，简称MSD法：先按k1排序分组，同一组中记录，关键码k1相等，再对各组按k2排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码kd对各子组排序后。再将各组连接起来，便得到一个有序序列。 最低位优先(Least Significant Digit first)法，简称LSD法：先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。 LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。 图解排序算法]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 命令]]></title>
    <url>%2F2018%2F04%2F08%2Fhexo-command%2F</url>
    <content type="text"><![CDATA[文章1$ hexo new &quot;new article&quot; 草稿草稿相当于很多博客都有的“私密文章”功能。1$ hexo new draft &quot;new draft&quot; 会在source/drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动drafts目录之中。 如果你希望强行预览草稿，更改配置文件：1$ render_drafts: true 或者，如下方式启动server：1$ hexo server --drafts 下面这条命令可以把草稿变成文章，或者页面：1$ hexo publish [layout] &lt;filename&gt; hexo123npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写12345hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 服务器12345678hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动12hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动 完成后部署123456两个命令的作用是相同的hexo generate --deployhexo deploy --generatehexo deploy -ghexo server -g 草稿1hexo publish [layout] &lt;title&gt; 模版123456789hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #将.deploy目录部署到GitHubhexo new [layout] &lt;title&gt;hexo new photo &quot;My Gallery&quot;hexo new &quot;Hello World&quot; --lang tw 模版（Scaffold）1hexo new photo &quot;My Gallery&quot; 写作12hexo new page &lt;title&gt;hexo new post &lt;title&gt; 推送到服务器上123hexo n #写文章hexo g #生成hexo d #部署 #可与hexo g合并为 hexo d -g]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[简记Hexo及NexT主题的安装使用]]></title>
    <url>%2F2018%2F04%2F08%2Fhexo-next-startup%2F</url>
    <content type="text"><![CDATA[官方文档：Hexo中文文档NexT中文文档NexT源码 在Mac系统下搞了个博客，简单的记述一下从无到有的过程。在官方文档里有详细的安装以及使用教程，不想看文档的话可以按照下面的步骤快速的搭建。 安装 Homebrew1$ ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 安装 Git1$ brew install git 安装 nvmnvm: Node Version Manager，安装 Node.js 的最佳方式是使用 nvm。123$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh// 或者$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.9/install.sh | bash 安装完成后，重启终端nvm环境才生效。 安装 Node.js1$ nvm install stable 安装 Hexo1$ npm install -g hexo-cli hexo 简单的命令格式，比如：hexo g == hexo generatehexo d == hexo deployhexo s == hexo serverhexo n == hexo new 创建博客123456$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install$ hexo n "我的新博客"$ hexo g -d$ hexo s 浏览器输入：http://localhost:4000 就可以看到了 Hexo目录：_config.yml 博客的配置文件scaffolds 博客文章模板source 博客文章目录themes 存放主题文件 Tip: hexo deploy出错解决方法： 1$ npm install hexo-deployer-git --save 安装 NexT 主题1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 配置主题打开站点配置文件_config.yml，找到theme字段，并将其值更改为next1theme: next 更改主题外观找到 …/themes/next/_config.yml 文件，更改 scheme 字段12345# Schemes# scheme: Musescheme: Mist# scheme: Pisces# scheme: Gemini 使主题生效：123$ hexo clean$ hexo g -d$ hexo s 到这里博客的本地搭建已经完成了，这只是开始。如果想要博客让别人也能看见，那就得申请域名把博客部署到服务器，然后别人通过域名访问就可以浏览你的博客啦。当然你可以把博客部署到GitHub或者Coding又或者别的服务器等，域名购买有DNSPod，万网，GoDaddy等等，有国内，国外自己考虑，之后还想要自己的博客有个性或者更好用那就选一个好看的主题DIY了。 至于写Markdown写作工具，各有所爱，我用的是Sublime Text，装上 Package Control，Markdown​Editing, Markdown Preview或者Omni​Markup​Previewer 等插件，就可以愉快的玩耍了。 以下列出的条目可供参考，或许能帮上你～ 部署本地文件到github及源代码托管参考：Hexo+GitHub Pages搭建的个人博客Mac搭建hexo博客 域名绑定参考 ：hexo边搭边记在github上搭建自己的主页和顶级域名的绑定 NexT主题定制参考：hexo框架基于next主题定制基于Hexo+Next主题的个人博客搭建定制优化hexo的next主题个性化教程:打造炫酷网站 Markdown 语法参考 ：Markdown 语法整理大集合2017]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
</search>
