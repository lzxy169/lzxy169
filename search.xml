<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[简记Hexo及NexT主题的安装使用]]></title>
    <url>%2F2018%2F04%2F10%2Fhexo_next_startup%2F</url>
    <content type="text"><![CDATA[官方文档：Hexo中文文档NexT中文文档NexT源码 在Mac系统下搞了个博客，简单的记述一下从无到有的过程。在官方文档里有详细的安装以及使用教程，不想看文档的话可以按照下面的步骤快速的搭建。 安装 Homebrew1$ ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 安装 Git1$ brew install git 安装 nvmnvm: Node Version Manager，安装 Node.js 的最佳方式是使用 nvm。1$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端nvm环境才生效。 安装 Node.js1$ nvm install stable 安装 Hexo1$ npm install -g hexo-cli hexo 简单的命令格式，比如：hexo g == hexo generatehexo d == hexo deployhexo s == hexo serverhexo n == hexo new 创建博客123456$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install$ hexo n "我的新博客"$ hexo g -d$ hexo s 浏览器输入：http://localhost:4000 就可以看到了 Hexo目录：_config.yml 博客的配置文件scaffolds 博客文章模板source 博客文章目录themes 存放主题文件 Tip: hexo deploy出错解决方法： 1$ npm install hexo-deployer-git --save 安装 NexT 主题1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 配置主题打开站点配置文件_config.yml，找到theme字段，并将其值更改为next1theme: next 更改主题外观找到 …/themes/next/_config.yml 文件，更改 scheme 字段12345# Schemes# scheme: Musescheme: Mist# scheme: Pisces# scheme: Gemini 使主题生效：123$ hexo clean$ hexo g -d$ hexo s 到这里博客的本地搭建已经完成了，这只是开始。如果想要博客让别人也能看见，那就得申请域名把博客部署到服务器，然后别人通过域名访问就可以浏览你的博客啦。当然你可以把博客部署到GitHub或者Coding又或者别的服务器等，域名购买有DNSPod，万网，GoDaddy等等，有国内，国外自己考虑，之后还想要自己的博客有个性或者更好用那就选一个好看的主题DIY了。 至于写Markdown写作工具，各有所爱，我用的是Sublime Text，装上 Package Control，Markdown​Editing, Markdown Preview或者Omni​Markup​Previewer 等插件，就可以愉快的玩耍了。 以下列出的条目可供参考，或许能帮上你～ 部署本地文件到github及源代码托管参考：Hexo+GitHub Pages搭建的个人博客Mac搭建hexo博客 域名绑定参考 ：hexo边搭边记在github上搭建自己的主页和顶级域名的绑定 NexT主题定制参考：hexo框架基于next主题定制基于Hexo+Next主题的个人博客搭建定制优化hexo的next主题个性化教程:打造炫酷网站]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法之排序]]></title>
    <url>%2F2018%2F04%2F09%2Falgorithm_sort%2F</url>
    <content type="text"><![CDATA[排序分为内部排序和外部排序，内部排序指待排序的记录在内存中，外部排序的记录数量很大，以至于内存放不下而放在外存中，排序过程需要访问外存。这里仅介绍内部排序，包括插入排序、交换排序、选择排序、归并排序、基数排序。 插入排序1，直接插入排序：就是检查第i个数字，如果在它的左边的数字比它大，进行交换，这个动作一直继续下去，直到这个数字的左边数字比它还要小，就可以停止了。插入排序法主要的回圈有两个变数：i和j，每一次执行这个回圈，就会将第i个数字放到左边恰当的位置去。 123456789101112131415// 直接插入 从小到大排序void insertSort(int a[], int n) &#123; for(int i = 1; i &lt; n; i++) &#123; int tmp = a[i]; int j = i - 1; while(tmp &lt; a[j]) &#123; a[j+1] = a[j]; j--; if(j == -1)&#123; break; &#125; &#125; a[j+1] = tmp; &#125;&#125; 12345678910void insertSort(int a[], int n) &#123; for(int i = 1; i &lt; n; i++) &#123; int tmp = a[i]; int j = i - 1; for (; j &gt;= 0 &amp;&amp; a[j] &gt; tmp; j--) &#123; a[j+1] = a[j]; &#125; a[j+1] = tmp; &#125;&#125; 2，折半插入排序（binary insertion sort）：当直接插入进行到某一趟时，对于a[i]来讲，前面i－1个记录已经按关键字有序。此时不用直接插入排序的方法，而改为折半查找，找出a[i]应插入的位置。 1234567891011121314151617181920// 折半插入 从小到大排序void binaryInsertSort(int a[], int n) &#123; for (int i = 1; i &lt; n; i++) &#123; int tmp = a[i]; int low = 0; int high = i - 1; while (low &lt;= high) &#123; int middle = (low + high) / 2; if (tmp &lt; a[middle]) &#123; high = middle - 1; &#125; else &#123; low = middle + 1; &#125; &#125; for (int j = i-1; j &gt;= low; j--) &#123; a[j+1] = a[j]; &#125; a[low] = tmp; &#125;&#125; 3，希尔排序：“缩小增量”的排序方法，初期选用增量较大间隔比较，然后增量缩小，最后为1，希尔排序对增量序列没有严格规定。 12345678910111213141516// 希尔排序 从小到大排序void shellSort(int a[], int n) &#123; int k = n / 2; while (k &gt; 0) &#123; for (int i = k; i &lt; n; i++) &#123; int tmp = a[i]; int j = i - k; while ((a[j] &gt; tmp) &amp;&amp; (j &gt;= 0)) &#123; a[j+k] = a[j]; j -= k; &#125; a[j+k] = tmp; &#125; k /= 2; &#125;&#125; 交换排序1，冒泡排序：面对一排数据，先从前往后两两比较，如果前一个数比后一个数大就交换两者的顺序，即第一个数和第二个数比，第二个数和第三个数比，……,倒数第二个数和最后一个数比，这样一轮下来以后最大的数就排到最后；接着把除去最大的数的该组数据进行同样的操作，直至这组数只剩下一个，排序结束。 123456789101112// 冒泡排序void bubbleSort(int a[] , int n) &#123; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n-i-1; j++) &#123; // 比较两个相邻的元素 if(a[j] &gt; a[j+1]) &#123; int t = a[j]; a[j] = a[j+1]; a[j+1] = t; &#125; &#125; &#125;&#125; 2，快速排序：选取一个基准元素(通常已需要排序的数组第一个数)，然后通过一趟排序将比基准数大的放在右边，比基准数小的放在左边，接着对划分好的两个数组再进行上述的排序。快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。挖坑填数进行总结1)．i =L; j = R; 将基准数挖出形成第一个坑a[i]。2)．j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。3)．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。4)．再重复执行2，3二步，直到i==j，将基准数填入a[i]中。 12345678910111213141516171819202122232425// 快速排序void qsort(int *a, int left, int right) &#123; if(left &gt;= right) &#123; // 如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了 return ; &#125; int i = left; int j = right; int key = a[left]; while(i &lt; j) &#123; // 控制在当前组内寻找一遍 while(i &lt; j &amp;&amp; key &lt;= a[j]) &#123; j--; // 向前寻找 &#125; a[i] = a[j]; // 将比第一个小的移到低端 while(i &lt; j &amp;&amp; key &gt;= a[i]) &#123; i++; // 向后寻找 &#125; a[j] = a[i]; // 将比第一个大的移到高端 &#125; a[i] = key; // 当在当组内找完一遍以后就把中间数key回归 qsort(a, left, i - 1); qsort(a, i + 1, right);&#125; 选择排序1，简单选择排序：面对一排数，假设第一个数是最小的，将第一个数依次与后面的所有数据进行比较，如发现更小的就把该数的下标记录下来，再将这个数与后面的数比较，一轮下来以后如果发现最小的数的下标不是第一个，就与第一个数交换，这样就保证了第一个位置上的数是最小的；对除去第一个数的剩下的数做同样的操作，多轮循环之后，直到剩下最后一个数，排序结束。 12345678910111213141516// 简单选择排序void simpleChoiceSort(int a[], int n) &#123; for(int i = 0; i &lt; n; i++) &#123; int m = i; for(int j = i + 1; j &lt; n; j++) &#123; if(a[j] &lt; a[m]) &#123; // 如果第j个元素比第m个元素小，将j赋值给m m = j; &#125; &#125; if(i != m) &#123; // 交换m和i两个元素的位置 int t = a[i]; a[i] = a[m]; a[m] = t; &#125; &#125;&#125; 2，堆排序（heap sort）：堆有两个性质，一是堆中某个节点的值总是不大于或不小于其父节点的值，二是堆是一棵完全树。以从大到小排序为例，首先要把得到的数组构建为一个最小堆，这样父节点均是小于或者等于子结点，根节点就是最小值，然后让根节点与尾节点交换，这样一次之后，再把前n－1个元素构建出最小根堆，让根结点与第n－2个元素交换，依此类推，得到降序序列。时间复杂度：O(n log2n) 1234567891011121314151617181920212223242526272829303132333435363738394041// 堆排序 从大到小排序// 以i节点为根，调整为堆的算法，m是节点总数，i节点的子结点为i*2+1,i*2+2void heapMin(int a[100], int i, int m) &#123; // tmp保存根节点，j为左孩子编号 int j, tmp; tmp = a[i]; j = 2*i+1; while (j &gt; m) &#123; if (j+1 &lt; m &amp;&amp; a[j+1] &lt; a[j]) &#123; // 在左右孩子中找最小的 j++; &#125; if (a[j] &gt;= tmp) &#123; break; &#125; a[i] = a[j]; i = j; j = 2*i+1; &#125; a[i] = tmp;&#125;void heapSort(int a[100], int n)&#123; // n/2-1最后一个非叶子节点 // 下面这个操作是建立最小堆 for (int i = n/2-1; i &gt;= 0; i--) &#123; heapMin(r, i, n); &#125; // for语句为输出堆顶元素，调整堆操作 for (int j = n-1; j &gt;= 1; j--) &#123; // 堆顶与堆尾交换 int tmp = a[0]; a[0] = a[j]; a[j] = tmp; heapMin(r, 0, j); &#125; // 得到的就是降序序列 for (int i = 0; i &lt; n; i++) &#123; printf(" %d", a[i]); &#125;&#125; 归并排序（merge sort）1，两路归并排序（Merge Sort）：也就是我们常说的归并排序，也叫合并排序。归并操作即将两个顺序序列合并成一个顺序序列的方法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。最差时间复杂度：O(nlogn)平均时间复杂度：O(nlogn)最差空间复杂度：O(n)稳定性：稳定 归并操作的基本步骤如下：1.申请两个与已经排序序列相同大小的空间，并将两个序列拷贝其中；2.设定最初位置分别为两个已经拷贝排序序列的起始位置，比较两个序列元素的大小，依次选择相对小的元素放到原始序列；3.重复2直到某一拷贝序列全部放入原始序列，将另一个序列剩下的所有元素直接复制到原始序列尾。 设归并排序的当前区间是arr[low..high]，分治法的三个步骤是：1.分解：将当前区间一分为二，即求分裂点2.求解：递归地对两个子区间arr[low..mid]和arr[mid+1..high]进行归并排序；3.组合：将已排序的两个子区间arr[low..mid]和arr[mid+1..high]归并为一个有序的区间arr[low..high]。递归的终结条件：子区间长度为1（一个记录自然有序）。 1234567891011121314151617181920212223242526272829303132333435363738// 归并子算法// 将有序的arr[low...mid]和s[mid+1...high]归并为有序的tmp[low...high]void merge(int arr[], int tmp[], int low, int mid, int high) &#123; int i = low; int j = mid + 1; int k = low; while (i != mid + 1 &amp;&amp; j != high + 1) &#123; if (arr[i] &gt;= arr[j]) &#123; tmp[k++] = arr[j++]; &#125; else &#123; tmp[k++] = arr[i++]; &#125; &#125; while (i != mid + 1) &#123; tmp[k++] = arr[i++]; &#125; while (j != high + 1) &#123; tmp[k++] = arr[j++]; &#125; for (i = low; i &lt;= high; i++) &#123; arr[i] = tmp[i]; &#125;&#125;// 两路归并排序void mergeSort(int arr[], int tmp[], int low, int high) &#123; if (low &lt; high) &#123; int mid = (low + high) / 2; mergeSort(arr, tmp, low, mid); mergeSort(arr, tmp, mid + 1, high); merge(arr, tmp, low, mid, high); &#125;&#125; 基数排序（radix sort）又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。 最高位优先(Most Significant Digit first)法，简称MSD法：先按k1排序分组，同一组中记录，关键码k1相等，再对各组按k2排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码kd对各子组排序后。再将各组连接起来，便得到一个有序序列。 最低位优先(Least Significant Digit first)法，简称LSD法：先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。 LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>c++</tag>
      </tags>
  </entry>
</search>
