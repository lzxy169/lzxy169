<!DOCTYPE html>




<html class="theme-next mist" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />





<script>
(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/c2ad22ed.js","daovoice")
daovoice('init', {
      app_id: "c2ad22ed"
    });
  daovoice('update');
</script>




















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.1.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.1.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.1.0',
    sidebar: {"display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="递归(Recursive):当一个函数用它自己来定义时就称为时递归。阶乘、斐波那契数列和汉诺塔，帕斯卡三角形，也就是著名的杨辉三角1234567void recursion_loop(int i) &amp;#123;    if (i == 10)        return;    else        recursion_loop(i + 1);&amp;#125;// 调用： recursion_loo">
<meta name="keywords" content="c,c++">
<meta property="og:type" content="article">
<meta property="og:title" content="算法之应用">
<meta property="og:url" content="http://blog.lzxy169.com/2018/04/12/algorithm-application/index.html">
<meta property="og:site_name" content="Navy&#39;s Blog">
<meta property="og:description" content="递归(Recursive):当一个函数用它自己来定义时就称为时递归。阶乘、斐波那契数列和汉诺塔，帕斯卡三角形，也就是著名的杨辉三角1234567void recursion_loop(int i) &amp;#123;    if (i == 10)        return;    else        recursion_loop(i + 1);&amp;#125;// 调用： recursion_loo">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://blog.lzxy169.com/2018/04/12/algorithm-application/WechatIMG2.jpeg">
<meta property="og:updated_time" content="2018-08-02T12:04:26.779Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="算法之应用">
<meta name="twitter:description" content="递归(Recursive):当一个函数用它自己来定义时就称为时递归。阶乘、斐波那契数列和汉诺塔，帕斯卡三角形，也就是著名的杨辉三角1234567void recursion_loop(int i) &amp;#123;    if (i == 10)        return;    else        recursion_loop(i + 1);&amp;#125;// 调用： recursion_loo">
<meta name="twitter:image" content="http://blog.lzxy169.com/2018/04/12/algorithm-application/WechatIMG2.jpeg">



  <link rel="alternate" href="/atom.xml" title="Navy's Blog" type="application/atom+xml" />




  <link rel="canonical" href="http://blog.lzxy169.com/2018/04/12/algorithm-application/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>算法之应用 | Navy's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  

  <div class="container  page-post-detail">
    <div class="headband"></div>

    <a href="https://github.com/lzxy169" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> 

<div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Navy's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">行之于途而应于心</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
          
  <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
</li>

      

      
    </ul>
  

  
    

    
    
      
      
    
      
      
    
      
      
    
      
      
    
    

  


  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.lzxy169.com/2018/04/12/algorithm-application/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Navy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Navy's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">算法之应用</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-12T12:25:58+08:00">2018-04-12</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/12/algorithm-application/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/04/12/algorithm-application/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="递归-Recursive-当一个函数用它自己来定义时就称为时递归。阶乘、斐波那契数列和汉诺塔，帕斯卡三角形，也就是著名的杨辉三角"><a href="#递归-Recursive-当一个函数用它自己来定义时就称为时递归。阶乘、斐波那契数列和汉诺塔，帕斯卡三角形，也就是著名的杨辉三角" class="headerlink" title="递归(Recursive):当一个函数用它自己来定义时就称为时递归。阶乘、斐波那契数列和汉诺塔，帕斯卡三角形，也就是著名的杨辉三角"></a>递归(Recursive):当一个函数用它自己来定义时就称为时递归。阶乘、斐波那契数列和汉诺塔，帕斯卡三角形，也就是著名的杨辉三角</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void recursion_loop(int i) &#123;</span><br><span class="line">    if (i == 10)</span><br><span class="line">        return;</span><br><span class="line">    else</span><br><span class="line">        recursion_loop(i + 1);</span><br><span class="line">&#125;</span><br><span class="line">// 调用： recursion_loop(0);</span><br></pre></td></tr></table></figure>
<h3 id="取幂运算：计算x的N次方常见的算法是N-1次乘法自乘"><a href="#取幂运算：计算x的N次方常见的算法是N-1次乘法自乘" class="headerlink" title="取幂运算：计算x的N次方常见的算法是N-1次乘法自乘"></a>取幂运算：计算x的N次方常见的算法是N-1次乘法自乘</h3><p>递归的基准条件是：N==0  此时返回1（不调用自身）。<br>若N是偶数，则x的N次方等于 x<em>x的N/2次方。<br>若N是奇数，则x的N次方等于 x</em>x的N/2次方在乘以x。<br>时间复杂度：O($\log_2 n$)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">long int pow(long int x, unsigned int n) &#123;</span><br><span class="line">    if (n == 0)</span><br><span class="line">        return 1;</span><br><span class="line">    if (n == 1)</span><br><span class="line">        return x;</span><br><span class="line">    if ((x &amp; 1) == 0) &#123; // 偶数</span><br><span class="line">        return pow(x * x, n / 2);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">//        return pow(x * x, n / 2) * x;</span><br><span class="line">        return pow(x, n - 1) * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="阶乘：0-1，n-n-1-×n"><a href="#阶乘：0-1，n-n-1-×n" class="headerlink" title="阶乘：0!=1，n!=(n-1)!×n"></a>阶乘：0!=1，n!=(n-1)!×n</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static long factorial(const long n) &#123;</span><br><span class="line">    return 0 == n || 1 == n ? 1  : n * factorial(n - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="斐波那契数列-Fibonacci-：又称黄金分割数列-以递归的方法定义：F-0-0，F-1-1-F-n-F-n-1-F-n-2-（n-gt-2，n∈N-）"><a href="#斐波那契数列-Fibonacci-：又称黄金分割数列-以递归的方法定义：F-0-0，F-1-1-F-n-F-n-1-F-n-2-（n-gt-2，n∈N-）" class="headerlink" title="斐波那契数列(Fibonacci)：又称黄金分割数列,以递归的方法定义：F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）"></a>斐波那契数列(Fibonacci)：又称黄金分割数列,以递归的方法定义：F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）</h3><p>1, 1, 2, 3, 5, 8, 13, 21, 34…这个数列从第3项开始，每一项都等于前两项之和。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static long fib(const long n) &#123;</span><br><span class="line">    return 0 == n || 1 == n ? 1 : fib(n - 1) + fib(n - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="汉诺塔：假设有n片，移动次数是f-n-显然f-1-1-f-2-3-f-3-7，且f-k-1-2-f-k-1-等比数列-。此后不难证明-数学归纳法-f-n-2-n-1。"><a href="#汉诺塔：假设有n片，移动次数是f-n-显然f-1-1-f-2-3-f-3-7，且f-k-1-2-f-k-1-等比数列-。此后不难证明-数学归纳法-f-n-2-n-1。" class="headerlink" title="汉诺塔：假设有n片，移动次数是f(n).显然f(1)=1,f(2)=3,f(3)=7，且f(k+1)=2*f(k)+1 (等比数列)。此后不难证明(数学归纳法) f(n)=$2^n$-1。"></a>汉诺塔：假设有n片，移动次数是f(n).显然f(1)=1,f(2)=3,f(3)=7，且f(k+1)=2*f(k)+1 (等比数列)。此后不难证明(数学归纳法) f(n)=$2^n$-1。</h3><p>a(n) = 2<em>a(n-1) + 1;<br>a(n) + 1 = 2</em>(a(n-1) + 1);<br>于是{a(n)+1}是首项为a(1)=1，公比为2的等比数列，<br>求得a(n)+1 = $2^n$，所以a(n) = $2^n$ - 1;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void move(const char x, const int n, const char z) &#123;</span><br><span class="line">    printf(&quot;把圆盘 %d 从柱子 %c 移动到 %c 上\n&quot;, n, x, z);</span><br><span class="line">&#125;</span><br><span class="line">static void hanoi(const int n, const char x, const char y, const char z) &#123;</span><br><span class="line">    if (1 == n)</span><br><span class="line">        move(x, 1, z);          // 如果只有一个盘，则直接将它从x移动到z</span><br><span class="line">    else &#123;</span><br><span class="line">        hanoi(n - 1, x, z, y);  // 把1 ~ n - 1个盘从x移动到y，用z作为中转</span><br><span class="line">        move(x, n, z);           // 把第n个盘从x移动到z</span><br><span class="line">        hanoi(n - 1, y, x, z);  // 把1 ~ n - 1个盘从y移动到z，用x作为中转</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="帕斯卡三角形，也就是著名的杨辉三角-三角形边界上的数都是1，内部的每个数是位于它上面的两个数之和。"><a href="#帕斯卡三角形，也就是著名的杨辉三角-三角形边界上的数都是1，内部的每个数是位于它上面的两个数之和。" class="headerlink" title="帕斯卡三角形，也就是著名的杨辉三角:三角形边界上的数都是1，内部的每个数是位于它上面的两个数之和。"></a>帕斯卡三角形，也就是著名的杨辉三角:三角形边界上的数都是1，内部的每个数是位于它上面的两个数之和。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1    1</span><br><span class="line">1    2    1</span><br><span class="line">1    3    3    1</span><br><span class="line">1    4    6    4    1</span><br></pre></td></tr></table></figure>
<p>利用递归我们可以很容易地把问题转换为这个性质：<br>假设：f(row, col)表示杨辉三角的第row行的第col个元素，那么：</p>
<ol>
<li>f(row, col) = 1 (col = 1 或者 row = col)，也就是递归的停止条件。</li>
<li>f(row, col) = f(row - 1, col - 1) + f(row - 1, col)，也就是上一行的两个相邻元素的和。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static long GetElement(const long row, const long col) &#123;</span><br><span class="line">    if ((1 == col) || (row == col)) // 每行的外围两个元素为1</span><br><span class="line">        return 1;</span><br><span class="line">    else // 其余的部分为上一行的(col - 1)和(col)元素之和</span><br><span class="line">        return GetElement(row - 1, col - 1) + GetElement(row - 1, col);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="求两个整数的最大公约数。"><a href="#求两个整数的最大公约数。" class="headerlink" title="求两个整数的最大公约数。"></a>求两个整数的最大公约数。</h3><p>最大公约数:几个整数中公有的约数，叫做这几个数的公约数；其中最大的一个，叫做这几个数的最大公约数。<br>最小公倍数:公倍数(common multiple)指在两个或两个以上的自然数中，如果它们有相同的倍数，这些倍数就是它们的公倍数，其中除0以外最小的一个公倍数，叫做这几个数的最小公倍数。<br>两个数的乘积等于两个数的最大公约数和最小公倍数的乘积。</p>
<p>最大公约数：同时整除两个整数的最大整数。<br>最小公倍数 = (a * b)/最大公约数。</p>
<p>如果N整除A-B，那么我们就说A与B模N同余。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 1.直接遍历法</span><br><span class="line">int maxCommonDivisor(int a, int b) &#123;</span><br><span class="line">    int max = 0;</span><br><span class="line">    for (int i = 1; i &lt;=b; i++) &#123;</span><br><span class="line">        if (a % i == 0 &amp;&amp; b % i == 0) &#123;</span><br><span class="line">            max = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2.辗转相除法</span><br><span class="line">int maxCommonDivisor(int a, int b) &#123;</span><br><span class="line">    int r;</span><br><span class="line">    while(a % b &gt; 0) &#123;</span><br><span class="line">        r = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = r;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3.欧几里得算法计算最大公约数</span><br><span class="line">int gcd(int m, int n) &#123;</span><br><span class="line">    int rem;</span><br><span class="line">    while (n &gt; 0) &#123;</span><br><span class="line">        rem = m % n;</span><br><span class="line">        m = n;</span><br><span class="line">        n = rem;</span><br><span class="line">    &#125;</span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不用中间变量-用两种方法交换A和B的值"><a href="#不用中间变量-用两种方法交换A和B的值" class="headerlink" title="不用中间变量,用两种方法交换A和B的值"></a>不用中间变量,用两种方法交换A和B的值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 1.中间变量</span><br><span class="line">void swap(int a, int b) &#123;</span><br><span class="line">   int temp = a;</span><br><span class="line">   a = b;</span><br><span class="line">   b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2.加法</span><br><span class="line">void swap(int a, int b) &#123;</span><br><span class="line">   a = a + b;</span><br><span class="line">   b = a - b;</span><br><span class="line">   a = a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3.异或（相同为0，不同为1. 可以理解为不进位加法）</span><br><span class="line">void swap(int a, int b) &#123;</span><br><span class="line">   a = a ^ b;</span><br><span class="line">   b = a ^ b;</span><br><span class="line">   a = a ^ b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现一个字符串“how-are-you”的逆序输出（编程语言不限）。"><a href="#实现一个字符串“how-are-you”的逆序输出（编程语言不限）。" class="headerlink" title="实现一个字符串“how are you”的逆序输出（编程语言不限）。"></a>实现一个字符串“how are you”的逆序输出（编程语言不限）。</h3><p>如给定字符串为“hello world”,输出结果应当为“world hello”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> int spliterFunc(char *p) &#123;</span><br><span class="line">    char c[100][100];</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while (*p != &apos;\0&apos;) &#123;</span><br><span class="line">        if (*p == &apos; &apos;) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j = 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            c[i][j] = *p;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int k = i; k &gt;= 0; k--) &#123;</span><br><span class="line">        printf(&quot;%s&quot;, c[k]);</span><br><span class="line">        if (k &gt; 0) &#123;</span><br><span class="line">            printf(&quot; &quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="给定一个字符串，输出本字符串中只出现一次并且最靠前的那个字符的位置？"><a href="#给定一个字符串，输出本字符串中只出现一次并且最靠前的那个字符的位置？" class="headerlink" title="给定一个字符串，输出本字符串中只出现一次并且最靠前的那个字符的位置？"></a>给定一个字符串，输出本字符串中只出现一次并且最靠前的那个字符的位置？</h3><p>如“abaccddeeef”,字符是b,输出应该是2。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> char *strOutPut(char *);</span><br><span class="line">int compareDifferentChar(char, char *);</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    char *inputStr = &quot;abaccddeeef&quot;;</span><br><span class="line">    char *outputStr = strOutPut(inputStr);</span><br><span class="line">    printf(&quot;%c \n&quot;, *outputStr);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char *strOutPut(char *s) &#123;</span><br><span class="line">    char str[100];</span><br><span class="line">    char *p = s;</span><br><span class="line">    int index = 0;</span><br><span class="line">    while (*s != &apos;\0&apos;) &#123;</span><br><span class="line">        if (compareDifferentChar(*s, p) == 1) &#123;</span><br><span class="line">            str[index] = *s;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    return &amp;str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int compareDifferentChar(char c, char *s) &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    while (*s != &apos;\0&apos; &amp;&amp; i&lt;= 1) &#123;</span><br><span class="line">        if (*s == c) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (i == 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><p>二叉树的先序遍历为FBACDEGH,中序遍历为：ABDCEFGH,请写出这个二叉树的后序遍历结果。<br>ADECBHGF</p>
<p><img src="/2018/04/12/algorithm-application/WechatIMG2.jpeg" alt=""></p>
<p>先序遍历：++a<em>bc</em>+<em>defg          :根—–&gt;左——&gt;右 :先访问根节点，前序遍历左子树，再前序遍历右子树。（简记为：VLR）<br>中序遍历：(a+b</em>c)+((d<em>e+f)</em>g)    :左—–&gt;根—–&gt;右 :从根节点开始，中序遍历根节点的左子树，然后访问根节点，最后中序遍历右子树。（简记为：LVR）<br>后序遍历：abc<em>+de</em>f+g<em>+          :左—–&gt;右—–&gt;根 :从左到右先叶子后节点的方式遍历访问左右子树，左右子树都访问结束，才访问根节点。（简称LRV）<br>层序遍历：++</em>a<em>+gbc</em>fde          :左—&gt;右  上—&gt;下</p>
<p>先序+中序遍历还原二叉树：先序遍历是：ABDEGCFH 中序遍历是：DBGEACHF<br>首先从先序得到第一个为A，就是二叉树的根，回到中序，可以将其分为三部分：<br>左子树的中序序列DBGE，根A，右子树的中序序列CHF<br>接着将左子树的序列回到先序可以得到B为根，这样回到左子树的中序再次将左子树分割为三部分：<br>左子树的左子树D，左子树的根B，左子树的右子树GE<br>同样地，可以得到右子树的根为C<br>类似地将右子树分割为根C，右子树的右子树HF，注意其左子树为空<br>如果只有一个就是叶子不用再进行了，刚才的GE和HF再次这样运作，就可以将二叉树还原了。后序遍历：DGEBHFCA</p>
<h3 id="打印2-100之间的素数。质数大于等于2-不能被它本身和1以外的数整除"><a href="#打印2-100之间的素数。质数大于等于2-不能被它本身和1以外的数整除" class="headerlink" title="打印2-100之间的素数。质数大于等于2 不能被它本身和1以外的数整除"></a>打印2-100之间的素数。质数大于等于2 不能被它本身和1以外的数整除</h3><p>在一般领域，对正整数n，如果用2到  之间的所有整数去除，均无法整除，则n为质数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    for (int i = 2; i &lt; 100; i++) &#123;</span><br><span class="line">        int r = isPrime(i);</span><br><span class="line">        if (r == 1) &#123;</span><br><span class="line">            printf(&quot;%ld &quot;, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int isPrime(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i, s;</span><br><span class="line">    for(i = 2; i &lt;= sqrt(n); i++)</span><br><span class="line">        if(n % i == 0)  return 0;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="给一列无序数组，求出中位数并给出算法的时间复杂度。"><a href="#给一列无序数组，求出中位数并给出算法的时间复杂度。" class="headerlink" title="给一列无序数组，求出中位数并给出算法的时间复杂度。"></a>给一列无序数组，求出中位数并给出算法的时间复杂度。</h3><p>若数组有奇数个元素，中位数是a[(n-1)/2]；若数组有偶数个元素，中位数为a[n/2-1]和a[n/2]两个数的平均值。这里为方便起见，假设数组为奇数个元素。</p>
<p><strong>思路一：</strong>把无序数组排好序，取出中间的元素。时间复杂度取决于排序算法，最快是快速排序，O(nlogn)，或者是非比较的基数排序，时间为O(n),空间为O(n)。这明显不是我们想要的。</p>
<p><strong>思路二：</strong>采用快速排序的分治partition过程。任意挑一个元素，以该元素为支点，将数组分成两部分，左边是小于等于支点的，右边是大于支点的。如果左侧长度正好是(n - 1)/2，那么支点恰为中位数。如果左侧长度&lt;(n-1)/2, 那么中位数在右侧，反之，中位数在左侧。 进入相应的一侧继续寻找中位数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 快速排序的分治过程找无序数组的中位数  </span><br><span class="line">int partition(int a[], int low, int high) //快排的一次排序过程</span><br><span class="line">&#123;</span><br><span class="line">    int q = a[low];</span><br><span class="line">    while (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        while (low &lt; high &amp;&amp; a[high] &gt;= q)</span><br><span class="line">            high--;</span><br><span class="line">        a[low] = a[high];</span><br><span class="line">        while (low &lt; high &amp;&amp; a[low] &lt;= q)</span><br><span class="line">            low++;</span><br><span class="line">        a[high] = a[low];</span><br><span class="line">    &#125;</span><br><span class="line">    a[low] = q;</span><br><span class="line">    return low;</span><br><span class="line">&#125;</span><br><span class="line">int findMidium(int a[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    int index = n / 2;</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = n - 1;</span><br><span class="line">    int q = -1;</span><br><span class="line">    while (index != q)</span><br><span class="line">    &#123;</span><br><span class="line">        q = partition(a, left, right);</span><br><span class="line">        if (q &lt; index)</span><br><span class="line">            left = q + 1;</span><br><span class="line">        else if (q&gt;index)</span><br><span class="line">            right = q - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>思路三：</strong>将数组的前（n+1）／2个元素建立一个最小堆。然后，对于下一个元素，和堆顶的元素比较，如果小于等于，丢弃之，如果大于，则用该元素取代堆顶，再调整堆，接着看下一个元素。重复这个步骤，直到数组为空。当数组都遍历完了，（堆中元素为最大的（n+1）／2个元素，）堆顶的元素即是中位数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> //构建最小堆找无序数组的中位数  </span><br><span class="line">void nswap(int&amp; i, int&amp; j)</span><br><span class="line">&#123;</span><br><span class="line">    i = i^j;</span><br><span class="line">    j = i^j;</span><br><span class="line">    i = i^j;</span><br><span class="line">&#125;</span><br><span class="line">void minHeapify(int a[], int i, int len)</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    int least = i;</span><br><span class="line">    int l = i * 2 + 1;</span><br><span class="line">    int r = i * 2 + 2;</span><br><span class="line">    if (l &lt; len &amp;&amp; a[l] &lt; a[least])</span><br><span class="line">        least = l;</span><br><span class="line">    if (r &lt; len &amp;&amp; a[r] &lt; a[least])</span><br><span class="line">        least = r;</span><br><span class="line">    if (least != i)</span><br><span class="line">    &#123;</span><br><span class="line">        nswap(a[i], a[least]);</span><br><span class="line">        minHeapify(a, least, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void buildMinHeap(int a[], int len)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = (len-2) / 2; i &gt;= 0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        minHeapify(a, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int findMidium2(int a[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    buildMinHeap(a, (n + 1) / 2);</span><br><span class="line">    for (int i = (n + 1) / 2; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (a[i] &gt; a[0])</span><br><span class="line">        &#123;</span><br><span class="line">            nswap(a[i], a[0]);</span><br><span class="line">            minHeapify(a, 0,(n + 1) / 2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return a[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>引申一：查找N个元素中的第K个小的元素</strong><br>编程珠玑给出了一个时间复杂度O（N）的解决方案。该方案改编自快速排序。<br>经过快排的一次划分，<br>   1）如果左半部份的长度&gt;K-1，那么这个元素就肯定在左半部份了<br>   2）如果左半部份的长度==K-1，那么当前划分元素就是结果了。<br>   3）如果。。。。。。。&lt;K-1,那么这个元素就肯定在右半部分了。<br>并且，该方法可以用尾递归实现。效率更高。<br>也可以用来查找N个元素中的前K个小的元素，前K个大的元素。。。。等等。</p>
<p><strong>引申二：查找N个元素中的第K个小的元素，假设内存受限，仅能容下K/4个元素。</strong><br>分趟查找，<br>第一趟，用堆方法查找最小的K/4个小的元素，同时记录剩下的N-K/4个元素到外部文件。<br>第二趟，用堆方法从第一趟筛选出的N-K/4个元素中查找K/4个小的元素，同时记录剩下的N-K/2个元素到外部文件。<br>。。。<br>第四趟，用堆方法从第一趟筛选出的N-K/3个元素中查找K/4个小的元素，这是的第K/4小的元素即使所求。</p>
<h3 id="输入一个整型数组，求出子数组和的最大值，并给出算法的时间复杂度。"><a href="#输入一个整型数组，求出子数组和的最大值，并给出算法的时间复杂度。" class="headerlink" title="输入一个整型数组，求出子数组和的最大值，并给出算法的时间复杂度。"></a>输入一个整型数组，求出子数组和的最大值，并给出算法的时间复杂度。</h3><p>设b[i]表示a[0…i]的子数组和的最大值，且b[i]一定包含a[i]，即：<br>sum为子问题的最优解，</p>
<ol>
<li>包含a[i],即求b[i]的最大值，在计算b[i]时,可以考虑以下两种情况,因为a[i]要求一定包含在内，所以<br>  1) 当b[i-1]&gt;0, b[i] = b[i-1]+a[i]<br>  2) 当b[i-1]&lt;=0, b[i] = a[i], 当b[i-1]&lt;=0，这时候以a[i]重新作为b[i]的起点。     </li>
<li>不包含a[i],即a[0]~a[i-1]的最大值（即0~i-1局部问题的最优解),设为sum<br>最后比较b[i]和 sum，即,如果b[i] &gt;sum ,即b[i]为最优解,然后更新sum的值.<br>在实现时，bMax代表 b[k], sum更新前代表前一步子问题的最优解，更新后代表当前问题的最优解。实现如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//求数组的子数组和的最大值，时间复杂度为O(n)  </span><br><span class="line"></span><br><span class="line">int maxSumArr(int a[], int n,int* start, int* end)</span><br><span class="line">&#123;</span><br><span class="line">    int s, e;</span><br><span class="line">    int sum = a[0];</span><br><span class="line">    int bMax=a[0];</span><br><span class="line">    *start = *end = 0;</span><br><span class="line">    for (int i = 1; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (bMax &gt; 0) //情况一，子数组包含a[i]，且b[i-1]&gt;0（上一次的最优解大于0），b[i] = b[i-1]+a[i]</span><br><span class="line">        &#123;</span><br><span class="line">            bMax += a[i];</span><br><span class="line">            e = i;</span><br><span class="line">        &#125;</span><br><span class="line">        else     //情况二，子数组包含a[i]，且b[i-1]&lt;=0（上一次的最优解小于0），这时候以a[i]重新作为b[i]的起点。</span><br><span class="line">        &#123;</span><br><span class="line">            bMax = a[i];</span><br><span class="line">            s = i;</span><br><span class="line">            e = i;</span><br><span class="line">        &#125;            //情况三，子数组不包含a[i],即b[i]=sum</span><br><span class="line">        if (bMax &gt; sum)   //三种情况相比较，最大值作为更新后的最优解，存在sum</span><br><span class="line">        &#123;</span><br><span class="line">            sum = bMax;</span><br><span class="line">            *start = s;</span><br><span class="line">            *end = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/c/" rel="tag"><i class="fa fa-tag"></i> c</a>
          
            <a href="/tags/c/" rel="tag"><i class="fa fa-tag"></i> c++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/10/algorithm-search/" rel="next" title="算法之查找">
                <i class="fa fa-chevron-left"></i> 算法之查找
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/13/c:c++-memory-management/" rel="prev" title="C/C++内存管理">
                C/C++内存管理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="Navy" />
            
              <p class="site-author-name" itemprop="name">Navy</p>
              <p class="site-description motion-element" itemprop="description">行之于途而应于心</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/lzxy169" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://weibo.com/lzxy169/" target="_blank" title="WeiBo"><i class="fa fa-fw fa-weibo"></i>WeiBo</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#递归-Recursive-当一个函数用它自己来定义时就称为时递归。阶乘、斐波那契数列和汉诺塔，帕斯卡三角形，也就是著名的杨辉三角"><span class="nav-number">1.</span> <span class="nav-text">递归(Recursive):当一个函数用它自己来定义时就称为时递归。阶乘、斐波那契数列和汉诺塔，帕斯卡三角形，也就是著名的杨辉三角</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#取幂运算：计算x的N次方常见的算法是N-1次乘法自乘"><span class="nav-number">2.</span> <span class="nav-text">取幂运算：计算x的N次方常见的算法是N-1次乘法自乘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#阶乘：0-1，n-n-1-×n"><span class="nav-number">3.</span> <span class="nav-text">阶乘：0!=1，n!=(n-1)!×n</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#斐波那契数列-Fibonacci-：又称黄金分割数列-以递归的方法定义：F-0-0，F-1-1-F-n-F-n-1-F-n-2-（n-gt-2，n∈N-）"><span class="nav-number">4.</span> <span class="nav-text">斐波那契数列(Fibonacci)：又称黄金分割数列,以递归的方法定义：F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#汉诺塔：假设有n片，移动次数是f-n-显然f-1-1-f-2-3-f-3-7，且f-k-1-2-f-k-1-等比数列-。此后不难证明-数学归纳法-f-n-2-n-1。"><span class="nav-number">5.</span> <span class="nav-text">汉诺塔：假设有n片，移动次数是f(n).显然f(1)=1,f(2)=3,f(3)=7，且f(k+1)=2*f(k)+1 (等比数列)。此后不难证明(数学归纳法) f(n)=$2^n$-1。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#帕斯卡三角形，也就是著名的杨辉三角-三角形边界上的数都是1，内部的每个数是位于它上面的两个数之和。"><span class="nav-number">6.</span> <span class="nav-text">帕斯卡三角形，也就是著名的杨辉三角:三角形边界上的数都是1，内部的每个数是位于它上面的两个数之和。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#求两个整数的最大公约数。"><span class="nav-number">7.</span> <span class="nav-text">求两个整数的最大公约数。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不用中间变量-用两种方法交换A和B的值"><span class="nav-number">8.</span> <span class="nav-text">不用中间变量,用两种方法交换A和B的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现一个字符串“how-are-you”的逆序输出（编程语言不限）。"><span class="nav-number">9.</span> <span class="nav-text">实现一个字符串“how are you”的逆序输出（编程语言不限）。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#给定一个字符串，输出本字符串中只出现一次并且最靠前的那个字符的位置？"><span class="nav-number">10.</span> <span class="nav-text">给定一个字符串，输出本字符串中只出现一次并且最靠前的那个字符的位置？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树遍历"><span class="nav-number">11.</span> <span class="nav-text">二叉树遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#打印2-100之间的素数。质数大于等于2-不能被它本身和1以外的数整除"><span class="nav-number">12.</span> <span class="nav-text">打印2-100之间的素数。质数大于等于2 不能被它本身和1以外的数整除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#给一列无序数组，求出中位数并给出算法的时间复杂度。"><span class="nav-number">13.</span> <span class="nav-text">给一列无序数组，求出中位数并给出算法的时间复杂度。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输入一个整型数组，求出子数组和的最大值，并给出算法的时间复杂度。"><span class="nav-number">14.</span> <span class="nav-text">输入一个整型数组，求出子数组和的最大值，并给出算法的时间复杂度。</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">原创文章，版权声明：署名-非商业性使用-相同方式共享 2.5</span>

  

  
</div>



<div class="powered-by">
<i class="fa fa-user-md"></i>
<span id="busuanzi_container_site_uv">
  访问用户：<span id="busuanzi_value_site_uv"></span>
</span>
<span class="post-meta-divider">|</span>
</div>

<div class="powered-by">
<i class="fa fa-eye"></i>
<span id="busuanzi_container_site_pv">
  访问量：<span id="busuanzi_value_site_pv"></span>
</span>
<span class="post-meta-divider">|</span>
</div>

<div class="powered-by">
<i class="fa fa-book"></i>
<span id="busuanzi_container_page_pv">
  阅读量：<span id="busuanzi_value_page_pv"></span>
</span>
<span class="post-meta-divider">|</span>
</div>


  <div class="powered-by">Powered by Hexo</div>








        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.1.0"></script>



  

  
    <script id="dsq-count-scr" src="https://http-blog-lzxy169-com.disqus.com/count.js" async></script>
  

  
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'http://blog.lzxy169.com/2018/04/12/algorithm-application/';
        this.page.identifier = '2018/04/12/algorithm-application/';
        this.page.title = '算法之应用';
      };
      function loadComments () {
        var d = document, s = d.createElement('script');
        s.src = 'https://http-blog-lzxy169-com.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      }
      
        loadComments();
      
    </script>
  





	





  












  





  

  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  


  
  

  

  

  

  

</body>
</html>
